

export const runtime = "nodejs";
export const dynamic = "force-dynamic";

function cleanPhone(raw: string) {
  const d = String(raw || "").replace(/[^\d]/g, "");
  return d.length >= 7 ? d : "";
}

function cleanEmail(raw: string) {
  const e = String(raw || "").trim().toLowerCase();
  return e.includes("@") ? e : "";
}

function toMs(v: any) {
  try {
    if (!v) return 0;
    if (typeof v?.toDate === "function") return v.toDate().getTime();
    if (typeof v?.seconds === "number") return v.seconds * 1000;
    if (typeof v === "number") return v;
    return 0;
  } catch {
    return 0;
  }
}

function buyerKeyFromOrder(o: any) {
  const phone = cleanPhone(o?.customer?.phone || "");
  const email = cleanEmail(o?.customer?.email || "");
  return phone ? `phone:${phone}` : email ? `email:${email}` : "";
}

function planOrderScanCap(planKey: string) {
  const k = String(planKey || "FREE").toUpperCase();
  if (k === "APEX") return 10000;
  if (k === "MOMENTUM") return 6000;
  if (k === "LAUNCH") return 2000;
  return 800;
}

function cleanSegment(v: any): ReengagementSegment {
  const s = String(v || "").trim();
  const allowed: ReengagementSegment[] = [
    "buyers_all",
    "buyers_first",
    "buyers_repeat",
    "inactive_30",
    "inactive_60",
    "inactive_90",
    "abandoned",
    "vip",
  ];

  // backward compatibility
  if (s === "buyers") return "buyers_all";
  if (s === "abandoned") return "abandoned";

  return (allowed.includes(s as any) ? (s as ReengagementSegment) : "buyers_all") as ReengagementSegment;
}

function isPaid(o: any) {
  const pt = String(o?.paymentType || "");
  const ps = String(o?.paymentStatus || "");
  const orderStatus = String(o?.orderStatus || "");

  if (pt === "paystack_escrow") return true;
  if (ps === "paid") return true;

  if (
    orderStatus === "paid_held" ||
    orderStatus === "released_to_vendor_wallet" ||
    orderStatus === "awaiting_vendor_confirmation"
  ) {
    return true;
  }

  return false;
}

function isDelivered(o: any) {
  const ops = String(o?.opsStatus || o?.opsStatusEffective || "").trim();
  return ops === "delivered";
}

function amountNgn(o: any) {
  const a = Number(o?.amount || 0);
  if (Number.isFinite(a) && a > 0) return a;

  const k = Number(o?.amountKobo || 0);
  if (Number.isFinite(k) && k > 0) return k / 100;

  return 0;
}

type Agg = {
  key: string;

  phone: string;
  email: string;
  fullName: string;

  completedOrdersCount: number;
  completedTotalSpent: number;
  lastCompletedOrderMs: number;
  lastCompletedOrderId: string;

  lastAbandonedOrderMs: number;
  lastAbandonedOrderId: string;

  lastAnyOrderMs: number;
  lastAnyOrderId: string;
};

function buildSegments(args: { nowMs: number; people: Agg[]; allowSmartGroups: boolean; allowVip: boolean }) {
  const { nowMs, people, allowSmartGroups, allowVip } = args;

  const buyersAll = people.filter((p) => p.completedOrdersCount >= 1);

  const first = allowSmartGroups ? buyersAll.filter((p) => p.completedOrdersCount === 1) : [];
  const repeat = allowSmartGroups ? buyersAll.filter((p) => p.completedOrdersCount >= 2) : [];

  const inactive = (days: number) =>
    allowSmartGroups
      ? buyersAll.filter((p) => p.lastCompletedOrderMs > 0 && nowMs - p.lastCompletedOrderMs >= days * 86400000)
      : [];

  let vip: Agg[] = [];
  if (allowVip) {
    const sorted = [...buyersAll].sort((a, b) => (b.completedTotalSpent || 0) - (a.completedTotalSpent || 0));
    const take = Math.max(10, Math.min(200, Math.ceil(sorted.length * 0.1)));
    vip = sorted.slice(0, take);
  }

  const abandoned = people.filter((p) => p.lastAbandonedOrderMs > 0);

  return {
    buyers_all: buyersAll,
    buyers_first: first,
    buyers_repeat: repeat,
    inactive_30: inactive(30),
    inactive_60: inactive(60),
    inactive_90: inactive(90),
    abandoned,
    vip,
  } as Record<ReengagementSegment, Agg[]>;
}

export async function GET(req: Request) {
  try {
    const me = await requireAnyRole(req, ["owner", "staff"]);
    if (!me.businessId) return NextResponse.json({ ok: false, error: "Missing businessId" }, { status: 400 });

    await requireVendorUnlocked(me.businessId);

    const plan = await getBusinessPlanResolved(me.businessId);
    const planKey = String(plan.planKey || "FREE").toUpperCase();

    const reengagementEnabled = !!plan?.features?.reengagement;
    if (!reengagementEnabled) {
      return NextResponse.json(
        { ok: false, code: "FEATURE_LOCKED", error: "Upgrade to use Reâ€‘engagement." },
        { status: 403 }
      );
    }

    const allowSmartGroups = !!plan?.features?.reengagementSmartGroups;
    const allowVip = planKey === "APEX" && !!plan?.features?.reengagementAiRemix;

    const url = new URL(req.url);
    let segment = cleanSegment(url.searchParams.get("segment") || url.searchParams.get("audience"));

    const daysParam = Math.max(1, Math.min(365, Number(url.searchParams.get("days") || 90)));
    const q = String(url.searchParams.get("q") || "").trim().toLowerCase();

    // If smart groups is OFF, force segment to buyers_all (except abandoned)
    if (!allowSmartGroups && segment !== "abandoned") segment = "buyers_all";
    // VIP is only allowed if reengagementAiRemix is enabled for Apex
    if (segment === "vip" && !allowVip) segment = "buyers_all";

    const orderScanCap = planOrderScanCap(planKey);

    const nowMs = Date.now();
    const lookbackDays = Math.max(120, daysParam);
    const startMs = nowMs - lookbackDays * 86400000;
    const startTs = Timestamp.fromMillis(startMs);

    const snap = await adminDb
      .collection("orders")
      .where("businessId", "==", me.businessId)
      .where("createdAt", ">=", startTs)
      .limit(orderScanCap)
      .get();

    const orders = snap.docs.map((d) => ({ id: d.id, ...(d.data() as any) }));
    orders.sort((a, b) => toMs(b.createdAt) - toMs(a.createdAt));

    const map = new Map<string, Agg>();

    for (const o of orders) {
      const key = buyerKeyFromOrder(o);
      if (!key) continue;

      const phone = cleanPhone(o?.customer?.phone || "");
      const email = cleanEmail(o?.customer?.email || "");
      const fullName = String(o?.customer?.fullName || "").trim();

      const ms = toMs(o.createdAt);
      const paid = isPaid(o);
      const delivered = isDelivered(o);
      const completed = paid || delivered;
      const amt = Math.max(0, amountNgn(o));

      const cur: Agg =
        map.get(key) ||
        ({
          key,
          phone,
          email,
          fullName,

          completedOrdersCount: 0,
          completedTotalSpent: 0,
          lastCompletedOrderMs: 0,
          lastCompletedOrderId: "",

          lastAbandonedOrderMs: 0,
          lastAbandonedOrderId: "",

          lastAnyOrderMs: 0,
          lastAnyOrderId: "",
        } as Agg);

      if (!cur.phone && phone) cur.phone = phone;
      if (!cur.email && email) cur.email = email;
      if (!cur.fullName && fullName) cur.fullName = fullName;

      if (ms && (!cur.lastAnyOrderMs || ms > cur.lastAnyOrderMs)) {
        cur.lastAnyOrderMs = ms;
        cur.lastAnyOrderId = String(o.id || "");
      }

      if (completed) {
        cur.completedOrdersCount += 1;
        cur.completedTotalSpent += amt;
        if (ms && (!cur.lastCompletedOrderMs || ms > cur.lastCompletedOrderMs)) {
          cur.lastCompletedOrderMs = ms;
          cur.lastCompletedOrderId = String(o.id || "");
        }
      } else {
        if (ms && (!cur.lastAbandonedOrderMs || ms > cur.lastAbandonedOrderMs)) {
          cur.lastAbandonedOrderMs = ms;
          cur.lastAbandonedOrderId = String(o.id || "");
        }
      }

      map.set(key, cur);
    }

    let people = Array.from(map.values()).filter((p) => !!p.phone);

    const segments = buildSegments({ nowMs, people, allowSmartGroups, allowVip });

    let list = segments[segment] || segments.buyers_all;

    if (segment === "abandoned") {
      const cutoffMs = nowMs - Math.max(1, Math.min(365, daysParam)) * 86400000;
      list = list.filter((p) => p.lastAbandonedOrderMs >= cutoffMs);
    }

    if (q) {
      list = list.filter((p) => {
        const n = String(p.fullName || "").toLowerCase();
        const ph = String(p.phone || "");
        const em = String(p.email || "").toLowerCase();
        return n.includes(q) || ph.includes(q) || em.includes(q);
      });
    }

    if (segment === "vip") {
      list.sort((a, b) => (b.completedTotalSpent || 0) - (a.completedTotalSpent || 0));
    } else if (segment.startsWith("inactive_")) {
      list.sort((a, b) => (a.lastCompletedOrderMs || 0) - (b.lastCompletedOrderMs || 0));
    } else {
      list.sort(
        (a, b) =>
          (b.lastCompletedOrderMs || b.lastAnyOrderMs || 0) - (a.lastCompletedOrderMs || a.lastAnyOrderMs || 0)
      );
    }

    const toPerson = (p: Agg) => ({
      key: p.key,
      phone: p.phone || null,
      email: p.email || null,
      fullName: p.fullName || null,

      ordersCount: p.completedOrdersCount,
      totalSpent: Number((p.completedTotalSpent || 0).toFixed(2)),
      lastOrderMs: p.lastCompletedOrderMs || p.lastAnyOrderMs || 0,
      lastOrderId: (p.lastCompletedOrderId || p.lastAnyOrderId || "").trim() || null,

      lastAbandonedOrderMs: p.lastAbandonedOrderMs || 0,
      lastAbandonedOrderId: p.lastAbandonedOrderId || null,
    });

    const counts = {
      buyers_all: segments.buyers_all.length,
      buyers_first: segments.buyers_first.length,
      buyers_repeat: segments.buyers_repeat.length,
      inactive_30: segments.inactive_30.length,
      inactive_60: segments.inactive_60.length,
      inactive_90: segments.inactive_90.length,
      abandoned: segments.abandoned.length,
      vip: segments.vip.length,
    };

    return NextResponse.json({
      ok: true,
      meta: {
        planKey,
        features: plan.features,
        limits: plan.limits,
        orderScanCap,
        lookbackDays,
      },
      segment,
      days: daysParam,
      counts,
      total: list.length,
      people: list.slice(0, 500).map(toPerson),
    });
  } catch (e: any) {
    if (e?.code === "VENDOR_LOCKED") {
      return NextResponse.json({ ok: false, code: "VENDOR_LOCKED", error: "Subscribe to continue." }, { status: 403 });
    }
    return NextResponse.json({ ok: false, error: e?.message || "Failed" }, { status: 500 });
  }
}

// FILE: src/app/api/vendor/reengagement/remix/route.ts
import { NextResponse } from "next/server";
import crypto from "node:crypto";
import { requireAnyRole } from "@/lib/auth/server";
import { adminDb } from "@/lib/firebase/admin";
import { FieldValue } from "firebase-admin/firestore";
import { requireVendorUnlocked } from "@/lib/vendor/lockServer";
import { getBusinessPlanResolved } from "@/lib/vendor/planConfigServer";

export const runtime = "nodejs";
export const dynamic = "force-dynamic";

const WINDOW_MS = 24 * 60 * 60 * 1000;

function cleanPlanKey(v: any) {
  const k = String(v || "FREE").toUpperCase();
  return k === "LAUNCH" || k === "MOMENTUM" || k === "APEX" ? k : "FREE";
}

function capForPlan(planKey: string) {
  const k = cleanPlanKey(planKey);
  if (k === "LAUNCH") return 5;
  if (k === "MOMENTUM") return 25;
  if (k === "APEX") return Infinity; // unlimited
  return 0;
}

function suggestionForRemixLocked(planKey: string) {
  const k = cleanPlanKey(planKey);

  if (k === "LAUNCH") {
    return {
      action: "buy_addon",
      sku: "addon_reengage_remix_lite",
      title: "Buy Reâ€‘engagement AI remix (lite)",
      url: "/vendor/purchases",
    };
  }

  if (k === "MOMENTUM") {
    return {
      action: "buy_addon",
      sku: "addon_reengage_remix_apex_capped",
      title: "Buy Reâ€‘engagement AI remix (Apex engine, capped)",
      url: "/vendor/purchases",
    };
  }

  return {
    action: "upgrade",
    title: "Upgrade plan",
    url: "/vendor/subscription",
  };
}

function suggestionForRemixCapHit() {
  return {
    action: "upgrade",
    title: "Upgrade to Apex for unlimited AI remix",
    url: "/vendor/subscription",
  };
}

function newRotationKey() {
  return `rot_${Date.now().toString(36)}_${crypto.randomBytes(4).toString("hex")}`;
}

/**
 * Remix = "Regenerate" prompt
 * - counts per BUSINESS (not per staff)
 * - rolling 24h window (not midnight reset)
 * - soft-block when cap hit (HTTP 200 with ok:false)
 */
export async function POST(req: Request) {
  try {
    const me = await requireAnyRole(req, ["owner", "staff"]);
    if (!me.businessId) return NextResponse.json({ ok: false, error: "Missing businessId" }, { status: 400 });

    await requireVendorUnlocked(me.businessId);

    const plan = await getBusinessPlanResolved(me.businessId);
    const planKey = cleanPlanKey(plan.planKey);

    // Must be purchased on Launch/Momentum; core on Apex
    const remixEnabled = !!plan?.features?.reengagementAiRemix;

    if (!remixEnabled) {
      return NextResponse.json({
        ok: false,
        code: "FEATURE_LOCKED",
        error: "Reâ€‘engagement AI remix is not available on your account. Buy the addâ€‘on to unlock it.",
        suggestion: suggestionForRemixLocked(planKey),
      });
    }

    // If Apex: unlimited (still can return usage = null)
    const cap = capForPlan(planKey);
    if (!Number.isFinite(cap) || cap <= 0) {
      // If somehow enabled but cap invalid, treat as unlimited
      return NextResponse.json({ ok: true, rotationKey: newRotationKey(), usage: null });
    }

    if (cap === Infinity) {
      return NextResponse.json({ ok: true, rotationKey: newRotationKey(), usage: null });
    }

    const usageRef = adminDb.collection("vendorUsage").doc(String(me.businessId));
    const now = Date.now();

    let usedOut = 0;
    let windowStartOut = 0;
    let resetAtOut = 0;

    const allowed = await adminDb.runTransaction(async (tx) => {
      const snap = await tx.get(usageRef);
      const usage = snap.exists ? (snap.data() as any) : {};

      let windowStartMs = Number(usage.reengagementRemixWindowStartMs || 0);
      let used = Number(usage.reengagementRemixCount24h || 0);

      if (!windowStartMs || now - windowStartMs >= WINDOW_MS) {
        windowStartMs = now;
        used = 0;
      }

      const resetAtMs = windowStartMs + WINDOW_MS;

      if (used >= cap) {
        usedOut = used;
        windowStartOut = windowStartMs;
        resetAtOut = resetAtMs;
        return { ok: false as const, resetAtMs, used, windowStartMs };
      }

      used += 1;

      tx.set(
        usageRef,
        {
          businessId: String(me.businessId),
          reengagementRemixWindowStartMs: windowStartMs,
          reengagementRemixCount24h: used,
          reengagementRemixResetAtMs: resetAtMs,
          updatedAtMs: now,
          updatedAt: FieldValue.serverTimestamp(),
        },
        { merge: true }
      );

      usedOut = used;
      windowStartOut = windowStartMs;
      resetAtOut = resetAtMs;

      return { ok: true as const, resetAtMs, used, windowStartMs };
    });

    if (!allowed.ok) {
      return NextResponse.json({
        ok: false,
        code: "REMIX_CAP_REACHED",
        error: "AI remix cap reached. Please wait for the timer to reset.",
        resetAtMs: Number(allowed.resetAtMs || 0),
        usage: { cap, used: Number(allowed.used || 0), windowStartMs: Number(allowed.windowStartMs || 0) },
        suggestion: suggestionForRemixCapHit(),
      });
    }

    return NextResponse.json({
      ok: true,
      rotationKey: newRotationKey(),
      usage: { cap, used: usedOut, windowStartMs: windowStartOut, resetAtMs: resetAtOut },
    });
  } catch (e: any) {
    if (e?.code === "VENDOR_LOCKED") {
      return NextResponse.json({ ok: false, code: "VENDOR_LOCKED", error: "Subscribe to continue." }, { status: 403 });
    }
    return NextResponse.json({ ok: false, error: e?.message || "Failed" }, { status: 500 });
  }
}

// FILE: src/app/api/vendor/reengagement/send/route.ts
import { NextResponse } from "next/server";
import { requireRole } from "@/lib/auth/server";
import { adminDb } from "@/lib/firebase/admin";
import { FieldValue } from "firebase-admin/firestore";
import { requireVendorUnlocked } from "@/lib/vendor/lockServer";
import { moderateOutboundText } from "@/lib/moderation/simpleTextGuard";
import { getBusinessPlanResolved } from "@/lib/vendor/planConfigServer";
import {
  composeSmartMessage,
  type ReengagementPerson,
  type ReengagementSegment,
  type PlanKey,
} from "@/lib/vendor/reengagement/compose";

export const runtime = "nodejs";
export const dynamic = "force-dynamic";

function cleanPhone(raw: any) {
  const d = String(raw || "").replace(/[^\d]/g, "");
  return d.length >= 7 ? d : "";
}

function cleanSegment(v: any): ReengagementSegment {
  const s = String(v || "").trim();
  const allowed: ReengagementSegment[] = [
    "buyers_all",
    "buyers_first",
    "buyers_repeat",
    "inactive_30",
    "inactive_60",
    "inactive_90",
    "abandoned",
    "vip",
  ];

  if (s === "buyers") return "buyers_all";
  if (s === "abandoned") return "abandoned";

  return (allowed.includes(s as any) ? (s as ReengagementSegment) : "buyers_all") as ReengagementSegment;
}

function dayKey(d = new Date()) {
  const y = d.getFullYear();
  const m = String(d.getMonth() + 1).padStart(2, "0");
  const dd = String(d.getDate()).padStart(2, "0");
  return `${y}-${m}-${dd}`;
}

function clampText(s: string, max = 1200) {
  const t = String(s || "").trim();
  if (t.length <= max) return t;
  return t.slice(0, max).trim();
}

function safeRotationKey(v: any) {
  const s = String(v || "").trim();
  return s.replace(/[^a-zA-Z0-9:_-]/g, "").slice(0, 48) || dayKey();
}

export async function POST(req: Request) {
  try {
    const me = await requireRole(req, "owner");
    const businessId = me.businessId;

    if (!businessId) {
      return NextResponse.json({ ok: false, error: "Missing businessId" }, { status: 400 });
    }

    await requireVendorUnlocked(businessId);

    const plan = await getBusinessPlanResolved(businessId);
    const planKey = String(plan.planKey || "FREE").toUpperCase() as PlanKey;

    const reengagementEnabled = !!plan?.features?.reengagement;
    if (!reengagementEnabled) {
      return NextResponse.json(
        { ok: false, code: "FEATURE_LOCKED", error: "Upgrade to message customers." },
        { status: 403 }
      );
    }

    const dailyLimit = Number(plan?.limits?.reengagementDaily || 0);
    if (!Number.isFinite(dailyLimit) || dailyLimit <= 0) {
      return NextResponse.json(
        { ok: false, code: "FEATURE_LOCKED", error: "Upgrade to message customers." },
        { status: 403 }
      );
    }

    const allowSmartGroups = !!plan?.features?.reengagementSmartGroups;
    const allowSmartMessages = !!plan?.features?.reengagementSmartMessages;

    // âœ… AI Remix is:
    // - Apex core (enabled)
    // - Launch/Momentum ONLY if purchased add-on (planConfigServer applies this)
    const allowAiRemix = !!plan?.features?.reengagementAiRemix;

    // VIP is Apex-only, and requires AI Remix ON
    const allowVip = String(planKey || "").toUpperCase() === "APEX" && allowAiRemix;

    const body = await req.json().catch(() => ({}));

    let segment = cleanSegment(body.segment ?? body.audience);
    const baseText = clampText(String(body.baseText ?? body.text ?? ""), 1200);
    const rotationKey = safeRotationKey(body.rotationKey);

    // Enforce toggles:
    if (!allowSmartGroups && segment !== "abandoned") segment = "buyers_all";
    if (segment === "vip" && !allowVip) segment = "buyers_all";

    const peopleRaw = Array.isArray(body.people) ? body.people : [];

    const people: ReengagementPerson[] = peopleRaw
      .map((x: any) => ({
        key: String(x?.key || "").trim(),
        phone: cleanPhone(x?.phone),
        email: x?.email ? String(x.email) : null,
        fullName: x?.fullName ? String(x.fullName) : null,
        ordersCount: Number(x?.ordersCount || 0) || 0,
        totalSpent: Number(x?.totalSpent || 0) || 0,
        lastOrderMs: Number(x?.lastOrderMs || 0) || 0,
        lastOrderId: x?.lastOrderId ? String(x.lastOrderId) : null,
      }))
      // âœ… build fix: explicitly type callback param so noImplicitAny doesn't fail
      .filter((x: any) => !!x.key && !!x.phone)
      .slice(0, 500);

    if (!baseText) return NextResponse.json({ ok: false, error: "Message is required" }, { status: 400 });
    if (people.length < 1) return NextResponse.json({ ok: false, error: "No recipients" }, { status: 400 });

    const mod = moderateOutboundText(baseText);
    if (!mod.ok) {
      await adminDb.collection("vendorPolicyViolations").doc().set({
        businessId,
        businessSlug: me.businessSlug ?? null,
        type: "message_blocked",
        reason: mod.reason,
        hit: mod.hit ?? null,
        segment,
        createdAtMs: Date.now(),
        createdAt: FieldValue.serverTimestamp(),
      });

      return NextResponse.json(
        { ok: false, code: "BLOCKED_BY_POLICY", error: "Message blocked by safety policy." },
        { status: 400 }
      );
    }

    const dk = dayKey();
    const counterRef = adminDb.collection("businesses").doc(businessId).collection("reengagementCounters").doc(dk);

    const countRequested = people.length;

    const allowed = await adminDb.runTransaction(async (t) => {
      const snap = await t.get(counterRef);
      const cur = snap.exists ? Number((snap.data() as any)?.sentCount || 0) : 0;

      const remaining = Math.max(0, dailyLimit - cur);
      const take = Math.max(0, Math.min(remaining, countRequested));

      t.set(
        counterRef,
        {
          dayKey: dk,
          planKey,
          dailyLimit,
          sentCount: cur + take,
          updatedAtMs: Date.now(),
          updatedAt: FieldValue.serverTimestamp(),
          createdAtMs: snap.exists ? (snap.data() as any)?.createdAtMs || Date.now() : Date.now(),
          createdAt: snap.exists
            ? (snap.data() as any)?.createdAt || FieldValue.serverTimestamp()
            : FieldValue.serverTimestamp(),
        },
        { merge: true }
      );

      return { take, remainingAfter: Math.max(0, remaining - take), cur, dailyLimit };
    });

    const recipients = people.slice(0, allowed.take);

    const businessName = String(plan?.business?.name || me.businessSlug || "").trim() || null;
    const businessSlug = String(me.businessSlug || "").trim() || null;

    const out = recipients.map((p) => {
      const text = allowSmartMessages
        ? composeSmartMessage({
            planKey,
            features: {
              reengagementSmartMessages: true,
              reengagementAiRemix: allowAiRemix,
            },
            businessSlug,
            businessName,
            segment,
            baseText,
            person: p,
            rotationKey,
          })
        : baseText;

      return {
        key: String((p as any)?.key || ""),
        phone: cleanPhone((p as any)?.phone || ""),
        fullName: (p as any)?.fullName || null,
        text,
      };
    });

    const campaignRef = adminDb.collection("reengagementCampaigns").doc();
    await campaignRef.set({
      businessId,
      businessSlug: me.businessSlug ?? null,
      segment,
      baseText,
      rotationKey,
      recipientCount: out.length,
      createdByUid: me.uid,
      createdAtMs: Date.now(),
      createdAt: FieldValue.serverTimestamp(),
      planKey,
      flags: {
        smartGroups: allowSmartGroups,
        smartMessages: allowSmartMessages,
        aiRemix: allowAiRemix,
        vip: allowVip && segment === "vip",
      },
    });

    return NextResponse.json({
      ok: true,
      campaignId: campaignRef.id,
      segment,
      baseText,
      rotationKey,
      recipients: out,
      limit: { planKey, ...allowed },
    });
  } catch (e: any) {
    if (e?.code === "VENDOR_LOCKED") {
      return NextResponse.json(
        { ok: false, code: "VENDOR_LOCKED", error: "Subscribe to continue." },
        { status: 403 }
      );
    }
    return NextResponse.json({ ok: false, error: e?.message || "Failed" }, { status: 500 });
  }
}

// FILE: src/app/api/vendor/settings/notifications/route.ts
import { NextResponse } from "next/server";
import { requireAnyRole, requireRole } from "@/lib/auth/server";
import { adminDb } from "@/lib/firebase/admin";
import { requireVendorUnlocked } from "@/lib/vendor/lockServer";

export const runtime = "nodejs";
export const dynamic = "force-dynamic";

function pickBool(v: any, fallback: boolean) {
  return typeof v === "boolean" ? v : fallback;
}

export async function GET(req: Request) {
  try {
    const me = await requireAnyRole(req, ["owner", "staff"]);
    if (!me.businessId) return NextResponse.json({ ok: false, error: "Missing businessId" }, { status: 400 });

    await requireVendorUnlocked(me.businessId);

    const bizSnap = await adminDb.collection("businesses").doc(me.businessId).get();
    const biz = bizSnap.exists ? (bizSnap.data() as any) : {};
    const notif = biz?.settings?.notifications || {};

    return NextResponse.json({
      ok: true,
      staffNudgesEnabled: pickBool(notif.staffNudgesEnabled, false),
      staffPushEnabled: pickBool(notif.staffPushEnabled, false),
    });
  } catch (e: any) {
    return NextResponse.json({ ok: false, error: e?.message || "Failed" }, { status: 500 });
  }
}

export async function POST(req: Request) {
  try {
    const me = await requireRole(req, "owner");
    if (!me.businessId) return NextResponse.json({ ok: false, error: "Missing businessId" }, { status: 400 });

    await requireVendorUnlocked(me.businessId);

    const body = await req.json().catch(() => ({} as any));

    const patch: any = {};
    if (typeof body?.staffNudgesEnabled === "boolean") patch["settings.notifications.staffNudgesEnabled"] = body.staffNudgesEnabled;
    if (typeof body?.staffPushEnabled === "boolean") patch["settings.notifications.staffPushEnabled"] = body.staffPushEnabled;

    if (!Object.keys(patch).length) {
      return NextResponse.json({ ok: false, error: "No valid fields to update" }, { status: 400 });
    }

    await adminDb.collection("businesses").doc(me.businessId).set(patch, { merge: true });

    return NextResponse.json({ ok: true });
  } catch (e: any) {
    if (e?.code === "VENDOR_LOCKED") {
      return NextResponse.json({ ok: false, code: "VENDOR_LOCKED", error: "Subscribe to continue." }, { status: 403 });
    }
    return NextResponse.json({ ok: false, error: e?.message || "Failed" }, { status: 500 });
  }
}

// FILE: src/app/api/vendor/shipping/options/route.ts
import { NextResponse } from "next/server";
import { adminDb } from "@/lib/firebase/admin";

export const runtime = "nodejs";
export const dynamic = "force-dynamic";

export async function GET(req: Request) {
  try {
    const url = new URL(req.url);
    const storeSlug = String(url.searchParams.get("storeSlug") || "").trim();

    if (!storeSlug) {
      return NextResponse.json({ ok: false, error: "storeSlug required" }, { status: 400 });
    }

    const bizSnap = await adminDb
      .collection("businesses")
      .where("slug", "==", storeSlug)
      .limit(1)
      .get();

    if (bizSnap.empty) return NextResponse.json({ ok: false, error: "Store not found" }, { status: 404 });

    const bizDoc = bizSnap.docs[0];
    const businessId = bizDoc.id;

    const sSnap = await adminDb
      .collection("businesses")
      .doc(businessId)
      .collection("shippingOptions")
      .limit(200)
      .get();

    const options = sSnap.docs
      .map((d) => ({ id: d.id, ...(d.data() as any) }))
      .filter((o) => o.active !== false)
      .sort((a, b) => Number(a.sortOrder || 0) - Number(b.sortOrder || 0))
      .map((o) => ({
        id: o.id,
        type: o.type || "delivery",
        name: o.name || "Delivery",
        feeKobo: Number(o.feeKobo || 0),
        etaDays: Number(o.etaDays || 0),
        areasText: o.areasText || null,
      }));

    return NextResponse.json({ ok: true, businessId, storeSlug, options });
  } catch (e: any) {
    return NextResponse.json({ ok: false, error: e?.message || "Failed" }, { status: 500 });
  }
}

// FILE: src/app/api/vendor/shipping/route.ts
// FILE: src/app/api/vendor/shipping/route.ts
import { NextResponse } from "next/server";
import { requireRole } from "@/lib/auth/server";
import { adminDb } from "@/lib/firebase/admin";
import { FieldValue } from "firebase-admin/firestore";
import { requireVendorUnlocked } from "@/lib/vendor/lockServer";
import { getBusinessPlanResolved } from "@/lib/vendor/planConfigServer";

export const runtime = "nodejs";
export const dynamic = "force-dynamic";

type ShipType = "pickup" | "delivery";

function cleanType(v: any): ShipType {
  return String(v || "delivery") === "pickup" ? "pickup" : "delivery";
}

function clampInt(v: any, min: number, max: number) {
  const n = Math.floor(Number(v));
  if (!Number.isFinite(n)) return min;
  return Math.max(min, Math.min(max, n));
}

function clampKobo(v: any) {
  const n = Math.floor(Number(v));
  if (!Number.isFinite(n)) return 0;
  return Math.max(0, n);
}

function cleanText(v: any, max = 80) {
  return String(v || "").trim().slice(0, max);
}

export async function GET(req: Request) {
  try {
    const me = await requireRole(req, "owner");
    if (!me.businessId) return NextResponse.json({ ok: false, error: "Missing businessId" }, { status: 400 });

    await requireVendorUnlocked(me.businessId);

    const snap = await adminDb.collection("businesses").doc(me.businessId).collection("shippingOptions").limit(200).get();

    const options = snap.docs.map((d) => ({ id: d.id, ...(d.data() as any) })).sort((a, b) => Number(a.sortOrder || 0) - Number(b.sortOrder || 0));

    return NextResponse.json({ ok: true, options });
  } catch (e: any) {
    if (e?.code === "VENDOR_LOCKED") {
      return NextResponse.json({ ok: false, code: "VENDOR_LOCKED", error: "Your free access has ended. Subscribe to continue." }, { status: 403 });
    }
    return NextResponse.json({ ok: false, error: e?.message || "Failed" }, { status: 500 });
  }
}

export async function POST(req: Request) {
  try {
    const me = await requireRole(req, "owner");
    if (!me.businessId) return NextResponse.json({ ok: false, error: "Missing businessId" }, { status: 400 });

    await requireVendorUnlocked(me.businessId);

    const body = await req.json().catch(() => ({}));

    const id = body.id ? String(body.id) : "";
    const type = cleanType(body.type);

    const name = cleanText(body.name, 60);
    if (!name) return NextResponse.json({ ok: false, error: "Name is required" }, { status: 400 });

    // âœ… plan-config driven shipping options max (no hardcoded limits)
    if (!id) {
      const plan = await getBusinessPlanResolved(me.businessId);
      const max = Number(plan?.limits?.shippingOptionsMax || 0);

      if (!Number.isFinite(max) || max <= 0) {
        return NextResponse.json(
          { ok: false, code: "PLAN_LIMIT_SHIPPING_OPTIONS", error: "Your plan does not allow shipping options." },
          { status: 403 }
        );
      }

      const agg = await adminDb.collection("businesses").doc(me.businessId).collection("shippingOptions").count().get();
      const cur = Number((agg.data() as any)?.count || 0);

      if (cur >= max) {
        return NextResponse.json(
          {
            ok: false,
            code: "PLAN_LIMIT_SHIPPING_OPTIONS",
            error: `You have reached your shipping option limit (${max}). Upgrade to add more.`,
            limit: max,
            current: cur,
          },
          { status: 403 }
        );
      }
    }

    const feeKobo = clampKobo(body.feeKobo);
    const etaDays = clampInt(body.etaDays, 0, 30);
    const areasText = cleanText(body.areasText, 160);
    const active = body.active === false ? false : true;
    const sortOrder = clampInt(body.sortOrder, 0, 999);

    const ref = id
      ? adminDb.collection("businesses").doc(me.businessId).collection("shippingOptions").doc(id)
      : adminDb.collection("businesses").doc(me.businessId).collection("shippingOptions").doc();

    await ref.set(
      {
        businessId: me.businessId,
        businessSlug: me.businessSlug ?? null,

        type, // pickup | delivery
        name,
        feeKobo: type === "pickup" ? 0 : feeKobo,
        fee: (type === "pickup" ? 0 : feeKobo) / 100,

        etaDays,
        areasText: areasText || null,

        active,
        sortOrder,

        updatedAtMs: Date.now(),
        updatedAt: FieldValue.serverTimestamp(),
        createdAtMs: FieldValue.increment(0), // keep for backward compatibility
      },
      { merge: true }
    );

    // If doc is newly created, set createdAtMs only once
    const snap = await ref.get();
    const data = snap.data() as any;
    if (!data?.createdAtMs || Number(data.createdAtMs) === 0) {
      await ref.set({ createdAtMs: Date.now(), createdAt: FieldValue.serverTimestamp() }, { merge: true });
    }

    return NextResponse.json({ ok: true, id: ref.id });
  } catch (e: any) {
    if (e?.code === "VENDOR_LOCKED") {
      return NextResponse.json({ ok: false, code: "VENDOR_LOCKED", error: "Your free access has ended. Subscribe to continue." }, { status: 403 });
    }
    return NextResponse.json({ ok: false, error: e?.message || "Failed" }, { status: 500 });
  }
}

export async function DELETE(req: Request) {
  try {
    const me = await requireRole(req, "owner");
    if (!me.businessId) return NextResponse.json({ ok: false, error: "Missing businessId" }, { status: 400 });

    await requireVendorUnlocked(me.businessId);

    const url = new URL(req.url);
    const id = String(url.searchParams.get("id") || "").trim();
    if (!id) return NextResponse.json({ ok: false, error: "id required" }, { status: 400 });

    await adminDb.collection("businesses").doc(me.businessId).collection("shippingOptions").doc(id).delete();

    return NextResponse.json({ ok: true });
  } catch (e: any) {
    if (e?.code === "VENDOR_LOCKED") {
      return NextResponse.json({ ok: false, code: "VENDOR_LOCKED", error: "Your free access has ended. Subscribe to continue." }, { status: 403 });
    }
    return NextResponse.json({ ok: false, error: e?.message || "Failed" }, { status: 500 });
  }
}

// FILE: src/app/api/vendor/staff/route.ts
// FILE: src/app/api/vendor/staff/route.ts
import { NextResponse } from "next/server";
import { requireRole } from "@/lib/auth/server";
import { adminDb } from "@/lib/firebase/admin";
import { FieldValue } from "firebase-admin/firestore";
import { requireVendorUnlocked } from "@/lib/vendor/lockServer";
import { getStaffSeatState } from "@/lib/vendor/staffSeatsServer";

export const runtime = "nodejs";
export const dynamic = "force-dynamic";

function appUrlFrom(req: Request) {
  const env = process.env.NEXT_PUBLIC_APP_URL;
  if (env) return env.replace(/\/$/, "");
  const u = new URL(req.url);
  return u.origin;
}

function cleanEmail(v: any) {
  const e = String(v || "").trim().toLowerCase();
  if (!e.includes("@") || e.length < 5) return "";
  return e;
}

function cleanJobTitle(v: any) {
  const s = String(v || "").trim();
  if (!s) return "";
  return s.slice(0, 60);
}

function cleanPerms(p: any) {
  const obj = p && typeof p === "object" ? p : {};
  return {
    productsView: !!obj.productsView,
    productsManage: !!obj.productsManage,
    ordersView: !!obj.ordersView,
    ordersManage: !!obj.ordersManage,
    analyticsView: !!obj.analyticsView,
    storeManage: false,
    walletAccess: false,
    payoutAccess: false,
  };
}

function suggestionForStaffLimit(planKey: string) {
  const pk = String(planKey || "").toUpperCase();
  if (pk === "LAUNCH") {
    return {
      action: "buy_addon",
      sku: "addon_staff_plus1",
      title: "Buy Staff +1 seat",
      url: "/vendor/purchases",
    };
  }
  return {
    action: "upgrade",
    title: "Upgrade plan",
    url: "/vendor/subscription",
  };
}

export async function GET(req: Request) {
  try {
    const me = await requireRole(req, "owner");
    if (!me.businessId) return NextResponse.json({ ok: false, error: "Missing businessId" }, { status: 400 });

    await requireVendorUnlocked(me.businessId);

    const staffSnap = await adminDb.collection("businesses").doc(me.businessId).collection("staff").limit(200).get();
    const staff = staffSnap.docs.map((d) => ({ id: d.id, ...(d.data() as any) }));

    const invSnap = await adminDb.collection("staffInvites").where("businessId", "==", me.businessId).limit(200).get();
    const invites = invSnap.docs
      .map((d) => ({ id: d.id, ...(d.data() as any) }))
      .sort((a, b) => Number(b.createdAtMs || 0) - Number(a.createdAtMs || 0))
      .slice(0, 100);

    const seats = await getStaffSeatState(me.businessId);

    return NextResponse.json({ ok: true, staff, invites, seats });
  } catch (e: any) {
    if (e?.code === "VENDOR_LOCKED") {
      return NextResponse.json(
        { ok: false, code: "VENDOR_LOCKED", error: "Your free access has ended. Subscribe to continue." },
        { status: 403 }
      );
    }
    return NextResponse.json({ ok: false, error: e?.message || "Failed" }, { status: 500 });
  }
}

export async function POST(req: Request) {
  try {
    const me = await requireRole(req, "owner");
    if (!me.businessId) return NextResponse.json({ ok: false, error: "Missing businessId" }, { status: 400 });

    await requireVendorUnlocked(me.businessId);

    const seats = await getStaffSeatState(me.businessId);
    if (seats.seatLimit <= 0) {
      return NextResponse.json(
        {
          ok: false,
          code: "FEATURE_LOCKED",
          error: "Upgrade your plan to add staff members.",
          suggestion: { action: "upgrade", url: "/vendor/subscription" },
          seats,
        },
        { status: 403 }
      );
    }
    if (seats.used >= seats.seatLimit) {
      const sug = suggestionForStaffLimit(String(seats.planKey || ""));
      return NextResponse.json(
        {
          ok: false,
          code: "STAFF_LIMIT_REACHED",
          error:
            sug.action === "buy_addon"
              ? `You have reached your staff limit (${seats.seatLimit}). Buy +1 seat to add one more staff member.`
              : `You have reached your staff limit (${seats.seatLimit}). Upgrade to add more.`,
          suggestion: sug,
          seats,
        },
        { status: 403 }
      );
    }

    const body = await req.json().catch(() => ({}));
    const email = cleanEmail(body.email);
    const name = String(body.name || "").trim().slice(0, 80);
    const jobTitle = cleanJobTitle(body.jobTitle);
    const perms = cleanPerms(body.permissions);

    if (!email) return NextResponse.json({ ok: false, error: "Valid staff email is required" }, { status: 400 });

    const inviteRef = adminDb.collection("staffInvites").doc();
    const inviteId = inviteRef.id;

    const bizSnap = await adminDb.collection("businesses").doc(me.businessId).get();
    const biz = bizSnap.exists ? (bizSnap.data() as any) : {};
    const slug = String(biz?.slug || me.businessSlug || "");

    await inviteRef.set({
      businessId: me.businessId,
      businessSlug: slug || null,

      email,
      emailLower: email,
      name: name || null,
      jobTitle: jobTitle || null,

      permissions: perms,

      status: "pending", // pending | accepted | revoked
      createdAtMs: Date.now(),
      updatedAtMs: Date.now(),
      createdAt: FieldValue.serverTimestamp(),
      updatedAt: FieldValue.serverTimestamp(),
      createdByUid: me.uid,
    });

    // âœ… NEW: invite points to staff register page
    const inviteLink = `${appUrlFrom(req)}/staff/register?code=${encodeURIComponent(inviteId)}`;

    return NextResponse.json({ ok: true, inviteId, inviteLink });
  } catch (e: any) {
    if (e?.code === "VENDOR_LOCKED") {
      return NextResponse.json(
        { ok: false, code: "VENDOR_LOCKED", error: "Your free access has ended. Subscribe to continue." },
        { status: 403 }
      );
    }
    return NextResponse.json({ ok: false, error: e?.message || "Failed" }, { status: 500 });
  }
}

export async function DELETE(req: Request) {
  try {
    const me = await requireRole(req, "owner");
    if (!me.businessId) return NextResponse.json({ ok: false, error: "Missing businessId" }, { status: 400 });

    await requireVendorUnlocked(me.businessId);

    const url = new URL(req.url);
    const inviteId = String(url.searchParams.get("inviteId") || "");
    const staffUid = String(url.searchParams.get("staffUid") || "");

    if (!inviteId && !staffUid) {
      return NextResponse.json({ ok: false, error: "inviteId or staffUid required" }, { status: 400 });
    }

    if (inviteId) {
      const ref = adminDb.collection("staffInvites").doc(inviteId);
      await ref.set(
        { status: "revoked", updatedAtMs: Date.now(), updatedAt: FieldValue.serverTimestamp() },
        { merge: true }
      );
      return NextResponse.json({ ok: true });
    }

    if (staffUid) {
      const staffRef = adminDb.collection("businesses").doc(me.businessId).collection("staff").doc(staffUid);
      await staffRef.delete().catch(() => {});

      await adminDb
        .collection("users")
        .doc(staffUid)
        .set(
          {
            role: "customer",
            businessId: FieldValue.delete(),
            businessSlug: FieldValue.delete(),
            staffPermissions: FieldValue.delete(),
            staffJobTitle: FieldValue.delete(),
            updatedAt: FieldValue.serverTimestamp(),
          },
          { merge: true }
        );

      return NextResponse.json({ ok: true });
    }

    return NextResponse.json({ ok: false, error: "No action" }, { status: 400 });
  } catch (e: any) {
    if (e?.code === "VENDOR_LOCKED") {
      return NextResponse.json(
        { ok: false, code: "VENDOR_LOCKED", error: "Your free access has ended. Subscribe to continue." },
        { status: 403 }
      );
    }
    return NextResponse.json({ ok: false, error: e?.message || "Failed" }, { status: 500 });
  }
}

// FILE: src/app/api/vendor/store/route.ts
// FILE: src/app/api/vendor/store/route.ts
import { NextResponse } from "next/server";
import { requireRole } from "@/lib/auth/server";
import { adminDb } from "@/lib/firebase/admin";
import { FieldValue } from "firebase-admin/firestore";
import { requireVendorUnlocked } from "@/lib/vendor/lockServer";
import { getBusinessPlanResolved } from "@/lib/vendor/planConfigServer";
import { cleanListCsv, keywordsForBusiness } from "@/lib/search/keywords";

export const runtime = "nodejs";
export const dynamic = "force-dynamic";

function hasActiveSubscription(biz: any) {
  const exp = Number(biz?.subscription?.expiresAtMs || 0);
  return !!(biz?.subscription?.planKey && exp && exp > Date.now());
}

export async function GET(req: Request) {
  try {
    const me = await requireRole(req, "owner");
    if (!me.businessId) return NextResponse.json({ error: "Missing businessId" }, { status: 400 });

    await requireVendorUnlocked(me.businessId);

    const snap = await adminDb.collection("businesses").doc(me.businessId).get();
    if (!snap.exists) return NextResponse.json({ error: "Business not found" }, { status: 404 });

    return NextResponse.json({ ok: true, business: { id: snap.id, ...snap.data() } });
  } catch (e: any) {
    return NextResponse.json({ ok: false, error: e?.message || "Failed" }, { status: 500 });
  }
}

export async function POST(req: Request) {
  try {
    const me = await requireRole(req, "owner");
    if (!me.businessId) return NextResponse.json({ error: "Missing businessId" }, { status: 400 });

    await requireVendorUnlocked(me.businessId);

    const body = await req.json().catch(() => ({}));

    const bizSnap = await adminDb.collection("businesses").doc(me.businessId).get();
    const biz = bizSnap.exists ? (bizSnap.data() as any) : {};

    const plan = await getBusinessPlanResolved(me.businessId);
    const canCustomize = !!(plan.features as any)?.storeCustomize;

    const wantsContinueInChatEnabled = body.continueInChatEnabled === true;
    if (wantsContinueInChatEnabled && !hasActiveSubscription(biz)) {
      return NextResponse.json(
        { ok: false, code: "SUBSCRIPTION_REQUIRED", error: "Subscribe to enable Continue in Chat." },
        { status: 403 }
      );
    }

    const searchTags = cleanListCsv(body.searchTagsCsv);

    const patch: any = {
      name: typeof body.name === "string" ? body.name.trim() : undefined,
      description: typeof body.description === "string" ? body.description : undefined,
      state: typeof body.state === "string" ? body.state.trim() : undefined,
      city: typeof body.city === "string" ? body.city.trim() : undefined,
      whatsapp: typeof body.whatsapp === "string" ? body.whatsapp.trim() : undefined,
      instagram: typeof body.instagram === "string" ? body.instagram.trim().replace(/^@/, "") : undefined,

      logoUrl: canCustomize && typeof body.logoUrl === "string" ? body.logoUrl : undefined,
      bannerUrl: canCustomize && typeof body.bannerUrl === "string" ? body.bannerUrl : undefined,

      continueInChatEnabled: body.continueInChatEnabled === true ? true : false,

      // âœ… NEW: vendor keywords + search index
      searchTags,
      searchKeywords: keywordsForBusiness({
        slug: String(biz?.slug || ""),
        name: typeof body.name === "string" ? body.name.trim() : String(biz?.name || ""),
        description: typeof body.description === "string" ? body.description : String(biz?.description || ""),
        state: typeof body.state === "string" ? body.state.trim() : String(biz?.state || ""),
        city: typeof body.city === "string" ? body.city.trim() : String(biz?.city || ""),
        instagram: typeof body.instagram === "string" ? body.instagram.trim().replace(/^@/, "") : String(biz?.instagram || ""),
        tags: searchTags,
      }),

      updatedAt: FieldValue.serverTimestamp(),
    };

    Object.keys(patch).forEach((k) => patch[k] === undefined && delete patch[k]);

    await adminDb.collection("businesses").doc(me.businessId).set(patch, { merge: true });

    return NextResponse.json({ ok: true, planKey: plan.planKey, canCustomize });
  } catch (e: any) {
    return NextResponse.json({ ok: false, error: e?.message || "Failed" }, { status: 500 });
  }
}

// FILE: src/app/api/vendor/support/chat/route.ts
import { NextResponse } from "next/server";
import { requireAnyRole } from "@/lib/auth/server";

export const runtime = "nodejs";
export const dynamic = "force-dynamic";

type HistoryMsg = { role: "user" | "assistant"; text: string };

function cleanText(v: any, max = 2000) {
  const s = String(v ?? "").trim();
  if (!s) return "";
  return s.length <= max ? s : s.slice(0, max).trim();
}

function cleanModel(v: any) {
  return String(v || "")
    .trim()
    .replace(/^["']+/, "")
    .replace(/["']+$/, "")
    .trim();
}

function buildSystemPrompt() {
  return [
    "You are myBizHub customer care for vendors.",
    "Speak in friendly business language. No technical terms.",
    "Give step-by-step help with short bullets.",
    "If you need more details, ask 1â€“2 questions only.",
    "Do not ask for passwords, OTP codes, bank PINs, or card numbers.",
  ].join("\n");
}

function fallbackSupportReply(messageRaw: string) {
  const m = cleanText(messageRaw, 5000).toLowerCase();

  if (m.includes("views") || m.includes("sales") || m.includes("customers") || m.includes("grow")) {
    return [
      "To get more views and sales, do these 6 things:",
      "",
      "1) Fix your cover photo",
      "- Use a clear photo with good light",
      "- Make the product fill the frame (no dark/blurry pictures)",
      "",
      "2) Use a simple product name",
      "- Example: â€œBlack Menâ€™s Polo (Size Mâ€“XL)â€",
      "",
      "3) Price and stock must be correct",
      "- Out of stock = people stop clicking",
      "",
      "4) Add 3â€“5 photos",
      "- Front, back, close-up, and real-life photo",
      "",
      "5) Share your store link consistently",
      "- WhatsApp status, WhatsApp groups, Instagram stories",
      "",
      "6) Promote your best product (if you have promotion)",
      "- Start with your best seller, not your slowest product",
      "",
      "If you tell me your product name + price, Iâ€™ll suggest a better title and photo order.",
    ].join("\n");
  }

  return [
    "I can help.",
    "",
    "Tell me 2 things:",
    "1) What were you trying to do?",
    "2) What message did you see (copy it here)?",
  ].join("\n");
}

async function groqRequest(params: {
  apiKey: string;
  model: string;
  messages: Array<{ role: string; content: string }>;
}) {
  const url = "https://api.groq.com/openai/v1/chat/completions";

  const r = await fetch(url, {
    method: "POST",
    headers: {
      Authorization: `Bearer ${params.apiKey}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      model: params.model,
      messages: params.messages,
      temperature: 0.35,
      max_tokens: 350,
    }),
  });

  const j = await r.json().catch(() => ({} as any));

  if (!r.ok) {
    const msg = String(j?.error?.message || j?.message || "Groq request failed");
    return { ok: false as const, status: r.status, error: msg };
  }

  const text = String(j?.choices?.[0]?.message?.content || "");
  const out = cleanText(text, 2500);
  if (!out) return { ok: false as const, status: 500, error: "Empty reply" };

  return { ok: true as const, text: out };
}

function modelFallbackList(primary: string) {
  // Try a few common Groq model IDs (some accounts differ)
  const list = [
    primary,
    "llama-3.1-70b-versatile",
    "llama-3.1-8b-instant",
    "llama3-70b-8192",
    "mixtral-8x7b-32768",
  ].map(cleanModel);

  return Array.from(new Set(list.filter(Boolean)));
}

function buildMessagesWithSystem(system: string, history: HistoryMsg[], message: string) {
  return [
    { role: "system", content: system },
    ...history.map((m) => ({ role: m.role, content: cleanText(m.text, 1500) })),
    { role: "user", content: message },
  ];
}

// Some providers reject role=system depending on model/account.
// This fallback format removes system role and places it inside the first user message.
function buildMessagesWithoutSystem(system: string, history: HistoryMsg[], message: string) {
  const sysAsUser = `Support rules:\n${system}\n\nCustomer message:\n`;
  return [
    { role: "user", content: sysAsUser + message },
    ...history.map((m) => ({ role: m.role, content: cleanText(m.text, 1500) })),
  ];
}

export async function POST(req: Request) {
  try {
    const me = await requireAnyRole(req, ["owner", "staff"]);
    if (!me.businessId) {
      return NextResponse.json({ ok: false, error: "Missing businessId" }, { status: 400 });
    }

    const body = await req.json().catch(() => ({} as any));
    const message = cleanText(body?.message, 2000);

    const historyIn = Array.isArray(body?.history) ? (body.history as any[]) : [];
    const history: HistoryMsg[] = historyIn
      .map((x: any): HistoryMsg => ({
        role: x?.role === "assistant" ? "assistant" : "user",
        text: cleanText(x?.text, 1500),
      }))
      .filter((x) => !!x.text);

    if (!message) {
      return NextResponse.json({ ok: false, error: "Message is required" }, { status: 400 });
    }

    const apiKey = String(process.env.GROQ_API_KEY || "").trim();
    const envModel = cleanModel(process.env.GROQ_MODEL || "llama-3.1-70b-versatile");
    const models = modelFallbackList(envModel);
    const system = buildSystemPrompt();

    if (!apiKey) {
      return NextResponse.json({
        ok: true,
        reply: fallbackSupportReply(message),
        meta: { mode: "fallback_no_key" },
      });
    }

    let last: any = null;

    for (const model of models) {
      // 1) Try normal system role
      let res = await groqRequest({
        apiKey,
        model,
        messages: buildMessagesWithSystem(system, history, message),
      });

      // 2) If Groq says request is invalid (400), retry without system role format
      if (!res.ok && res.status === 400) {
        res = await groqRequest({
          apiKey,
          model,
          messages: buildMessagesWithoutSystem(system, history, message),
        });
      }

      if (res.ok) {
        return NextResponse.json({ ok: true, reply: res.text, meta: { mode: "groq", model } });
      }

      last = { status: res.status, error: res.error, model };
    }

    console.error("GROQ_SUPPORT_CHAT_FAILED", last);

    return NextResponse.json({
      ok: true,
      reply: fallbackSupportReply(message),
      meta: { mode: "fallback_after_error", lastStatus: last?.status || 0, lastModel: last?.model || null },
    });
  } catch (e: any) {
    return NextResponse.json({ ok: false, error: e?.message || "Failed" }, { status: 500 });
  }
}

// FILE: src/app/api/vendor/verification/route.ts
// FILE: src/app/api/vendor/verification/route.ts
import { NextResponse } from "next/server";
import { requireRole } from "@/lib/auth/server";
import { adminDb } from "@/lib/firebase/admin";
import { FieldValue } from "firebase-admin/firestore";
import { requireVendorUnlocked } from "@/lib/vendor/lockServer";
import { syncBusinessSignalsToProducts } from "@/lib/vendor/syncBusinessSignals";

export const runtime = "nodejs";
export const dynamic = "force-dynamic";

type TierKey = "tier1" | "tier2" | "tier3";

function cleanTier(v: any): TierKey {
  const s = String(v || "").trim();
  if (s === "tier1" || s === "tier2" || s === "tier3") return s;
  return "tier1";
}

function cleanUrls(arr: any) {
  const list: string[] = Array.isArray(arr) ? arr.map((x) => String(x || "").trim()) : [];
  return list.filter((u) => u.startsWith("https://")).slice(0, 10);
}

function cleanIdType(v: any) {
  const s = String(v || "").trim().toLowerCase();
  if (s === "nin") return "nin";
  if (s === "drivers_licence") return "drivers_licence";
  if (s === "voters_card") return "voters_card";
  if (s === "passport") return "passport";
  return "nin";
}

function cleanIdNumber(v: any) {
  const s = String(v || "").trim().replace(/\s+/g, "");
  return s.slice(0, 30);
}

export async function GET(req: Request) {
  try {
    const me = await requireRole(req, "owner");
    if (!me.businessId) return NextResponse.json({ ok: false, error: "Missing businessId" }, { status: 400 });

    await requireVendorUnlocked(me.businessId);

    const snap = await adminDb.collection("businesses").doc(me.businessId).get();
    if (!snap.exists) return NextResponse.json({ ok: false, error: "Business not found" }, { status: 404 });

    const biz = snap.data() as any;

    return NextResponse.json({
      ok: true,
      business: {
        id: me.businessId,
        slug: biz?.slug ?? null,
        name: biz?.name ?? null,
        state: biz?.state ?? null,
        city: biz?.city ?? null,
      },
      verification: biz?.verification ?? null,
      verificationTier: Number(biz?.verificationTier || 0),
      trust: biz?.trust ?? null,
    });
  } catch (e: any) {
    if (e?.code === "VENDOR_LOCKED") {
      return NextResponse.json({ ok: false, code: "VENDOR_LOCKED", error: "Subscribe to continue." }, { status: 403 });
    }
    return NextResponse.json({ ok: false, error: e?.message || "Failed" }, { status: 500 });
  }
}

export async function POST(req: Request) {
  try {
    const me = await requireRole(req, "owner");
    if (!me.businessId) return NextResponse.json({ ok: false, error: "Missing businessId" }, { status: 400 });

    await requireVendorUnlocked(me.businessId);

    const body = await req.json().catch(() => ({}));
    const tier = cleanTier(body.tier);

    const bizRef = adminDb.collection("businesses").doc(me.businessId);
    const bizSnap = await bizRef.get();
    if (!bizSnap.exists) return NextResponse.json({ ok: false, error: "Business not found" }, { status: 404 });

    const nowMs = Date.now();

    const verification = (bizSnap.data() as any)?.verification || {};

    const submissionRef = adminDb.collection("verificationSubmissions").doc();

    if (tier === "tier1") {
      // Tier 1: face check (guided photos) - auto-pass (your instruction)
      const selfieUrls = cleanUrls(body.selfieUrls);
      if (selfieUrls.length < 1) {
        return NextResponse.json({ ok: false, error: "Upload at least 1 clear selfie photo" }, { status: 400 });
      }

      verification.tier1 = {
        status: "verified", // auto
        method: "selfie_photos",
        selfieUrls,
        verifiedAtMs: nowMs,
        updatedAtMs: nowMs,
      };

      await bizRef.set(
        {
          verification,
          updatedAt: FieldValue.serverTimestamp(),
        },
        { merge: true }
      );

      await submissionRef.set({
        businessId: me.businessId,
        tier: "tier1",
        status: "auto_verified",
        payload: { selfieUrls },
        createdAtMs: nowMs,
        createdAt: FieldValue.serverTimestamp(),
        reviewedAtMs: nowMs,
      });

      await syncBusinessSignalsToProducts({ businessId: me.businessId });

      return NextResponse.json({ ok: true, tier: "tier1", status: "verified" });
    }

    if (tier === "tier2") {
      // Tier 2: ID number only (no photo) -> pending admin review
      const idType = cleanIdType(body.idType);
      const idNumber = cleanIdNumber(body.idNumber);

      if (!idNumber) {
        return NextResponse.json({ ok: false, error: "Enter a valid ID number" }, { status: 400 });
      }

      verification.tier2 = {
        status: "pending",
        idType,
        idNumber,
        submittedAtMs: nowMs,
        updatedAtMs: nowMs,
        adminNote: null,
      };

      await bizRef.set(
        {
          verification,
          updatedAt: FieldValue.serverTimestamp(),
        },
        { merge: true }
      );

      await submissionRef.set({
        businessId: me.businessId,
        tier: "tier2",
        status: "pending",
        payload: { idType, idNumber },
        createdAtMs: nowMs,
        createdAt: FieldValue.serverTimestamp(),
      });

      return NextResponse.json({ ok: true, tier: "tier2", status: "pending" });
    }

    if (tier === "tier3") {
      // Tier 3: proof of address (upload) -> pending admin review
      const proofUrls = cleanUrls(body.proofUrls);
      if (proofUrls.length < 1) {
        return NextResponse.json({ ok: false, error: "Upload proof of address" }, { status: 400 });
      }

      verification.tier3 = {
        status: "pending",
        proofUrls,
        submittedAtMs: nowMs,
        updatedAtMs: nowMs,
        adminNote: null,
      };

      await bizRef.set(
        {
          verification,
          updatedAt: FieldValue.serverTimestamp(),
        },
        { merge: true }
      );

      await submissionRef.set({
        businessId: me.businessId,
        tier: "tier3",
        status: "pending",
        payload: { proofUrls },
        createdAtMs: nowMs,
        createdAt: FieldValue.serverTimestamp(),
      });

      return NextResponse.json({ ok: true, tier: "tier3", status: "pending" });
    }

    return NextResponse.json({ ok: false, error: "Unknown tier" }, { status: 400 });
  } catch (e: any) {
    if (e?.code === "VENDOR_LOCKED") {
      return NextResponse.json({ ok: false, code: "VENDOR_LOCKED", error: "Subscribe to continue." }, { status: 403 });
    }
    return NextResponse.json({ ok: false, error: e?.message || "Failed" }, { status: 500 });
  }
}

// FILE: src/app/api/vendor/wallet/route.ts
import { NextResponse } from "next/server";
import { requireRole } from "@/lib/auth/server";
import { adminDb } from "@/lib/firebase/admin";
import { requireVendorUnlocked } from "@/lib/vendor/lockServer";

export const runtime = "nodejs";
export const dynamic = "force-dynamic";

export async function GET(req: Request) {
  try {
    const me = await requireRole(req, "owner");
    if (!me.businessId) {
      return NextResponse.json({ ok: false, error: "Missing businessId" }, { status: 400 });
    }

    await requireVendorUnlocked(me.businessId);

    const snap = await adminDb.collection("wallets").doc(me.businessId).get();
    return NextResponse.json({ ok: true, wallet: snap.exists ? snap.data() : null });
  } catch (e: any) {
    if (e?.code === "VENDOR_LOCKED") {
      return NextResponse.json(
        { ok: false, code: "VENDOR_LOCKED", error: "Your free access has ended. Subscribe to continue." },
        { status: 403 }
      );
    }
    return NextResponse.json({ ok: false, error: e?.message || "Unauthorized" }, { status: 401 });
  }
}

// FILE: src/app/api/vendor/withdrawals/route.ts
import { NextResponse } from "next/server";
import { requireRole } from "@/lib/auth/server";
import { adminDb } from "@/lib/firebase/admin";
import { FieldValue } from "firebase-admin/firestore";
import { requireVendorUnlocked } from "@/lib/vendor/lockServer";

export const runtime = "nodejs";
export const dynamic = "force-dynamic";

function clampKobo(v: any) {
  const n = Math.floor(Number(v));
  if (!Number.isFinite(n)) return 0;
  return Math.max(0, n);
}

export async function GET(req: Request) {
  try {
    const me = await requireRole(req, "owner");
    if (!me.businessId) return NextResponse.json({ ok: false, error: "Missing businessId" }, { status: 400 });

    await requireVendorUnlocked(me.businessId);

    const snap = await adminDb
      .collection("withdrawals")
      .where("businessId", "==", me.businessId)
      .limit(50)
      .get();

    const list = snap.docs
      .map((d) => ({ id: d.id, ...(d.data() as any) }))
      .sort((a, b) => Number(b.createdAtMs || 0) - Number(a.createdAtMs || 0))
      .slice(0, 20);

    // Wallet summary for UI
    const wSnap = await adminDb.collection("wallets").doc(me.businessId).get();
    const wallet = wSnap.exists ? (wSnap.data() as any) : null;

    return NextResponse.json({ ok: true, withdrawals: list, wallet });
  } catch (e: any) {
    if (e?.code === "VENDOR_LOCKED") {
      return NextResponse.json({ ok: false, code: "VENDOR_LOCKED", error: "Your free access has ended. Subscribe to continue." }, { status: 403 });
    }
    return NextResponse.json({ ok: false, error: e?.message || "Failed" }, { status: 500 });
  }
}

export async function POST(req: Request) {
  try {
    const me = await requireRole(req, "owner");
    if (!me.businessId) return NextResponse.json({ ok: false, error: "Missing businessId" }, { status: 400 });

    // hard lock enforcement
    await requireVendorUnlocked(me.businessId);

    const body = await req.json().catch(() => ({}));
    const amountKobo = clampKobo(body.amountKobo);

    // Minimum â‚¦1000
    if (amountKobo < 1000 * 100) {
      return NextResponse.json({ ok: false, error: "Minimum withdrawal is â‚¦1,000" }, { status: 400 });
    }

    const bizSnap = await adminDb.collection("businesses").doc(me.businessId).get();
    if (!bizSnap.exists) return NextResponse.json({ ok: false, error: "Business not found" }, { status: 404 });
    const biz = bizSnap.data() as any;

    const payout = biz?.payoutDetails || null;
    const bankName = String(payout?.bankName || "").trim();
    const accountNumber = String(payout?.accountNumber || "").trim();
    const accountName = String(payout?.accountName || "").trim();

    if (!bankName || !accountNumber || !accountName) {
      return NextResponse.json(
        { ok: false, code: "MISSING_PAYOUT_DETAILS", error: "Add payout details before requesting withdrawal." },
        { status: 400 }
      );
    }

    const walletRef = adminDb.collection("wallets").doc(me.businessId);
    const wdRef = adminDb.collection("withdrawals").doc();

    const result = await adminDb.runTransaction(async (t) => {
      const wSnap = await t.get(walletRef);
      const w = wSnap.exists ? (wSnap.data() as any) : null;

      const available = Number(w?.availableBalanceKobo || 0);
      const hold = Number(w?.withdrawHoldKobo || 0);

      if (!Number.isFinite(available) || available <= 0) {
        return { ok: false, status: 400, error: "No available balance" as const };
      }
      if (amountKobo > available) {
        return { ok: false, status: 400, error: "Amount exceeds available balance" as const };
      }

      const nowMs = Date.now();

      // Create withdrawal request (status pending)
      t.set(wdRef, {
        businessId: me.businessId,
        businessSlug: biz?.slug ?? me.businessSlug ?? null,
        requestedByUid: me.uid,

        amountKobo,
        amount: amountKobo / 100,
        currency: "NGN",

        payoutDetails: {
          bankName,
          accountNumber,
          accountName,
        },

        status: "pending", // pending | approved | rejected | paid
        createdAtMs: nowMs,
        updatedAtMs: nowMs,
        createdAt: FieldValue.serverTimestamp(),
        updatedAt: FieldValue.serverTimestamp(),
      });

      // Move funds: available -> hold
      t.set(
        walletRef,
        {
          businessId: me.businessId,
          availableBalanceKobo: FieldValue.increment(-amountKobo),
          withdrawHoldKobo: FieldValue.increment(amountKobo),
          updatedAt: FieldValue.serverTimestamp(),
        },
        { merge: true }
      );

      return { ok: true, withdrawalId: wdRef.id, amountKobo, holdAfter: hold + amountKobo, availableAfter: available - amountKobo };
    });

    if ((result as any).ok === false) {
      const r: any = result;
      return NextResponse.json({ ok: false, error: r.error }, { status: r.status || 400 });
    }

    return NextResponse.json(result);
  } catch (e: any) {
    if (e?.code === "VENDOR_LOCKED") {
      return NextResponse.json({ ok: false, code: "VENDOR_LOCKED", error: "Your free access has ended. Subscribe to continue." }, { status: 403 });
    }
    return NextResponse.json({ ok: false, error: e?.message || "Failed" }, { status: 500 });
  }
}

// FILE: src/app/vendor/analytics/page.tsx
// FILE: src/app/vendor/analytics/page.tsx
"use client";

import { useEffect, useMemo, useState } from "react";
import { useRouter } from "next/navigation";
import GradientHeader from "@/components/GradientHeader";
import { Card } from "@/components/Card";
import { SectionCard } from "@/components/ui/SectionCard";
import { SegmentedControl } from "@/components/ui/SegmentedControl";
import { AnalyticsChart } from "@/components/charts/AnalyticsChart";
import { auth } from "@/lib/firebase/client";
import { 
  TrendingUp, 
  TrendingDown, 
  Eye, 
  ShoppingCart, 
  Users, 
  DollarSign,
  RefreshCw,
  Calendar,
  Percent,
  Package
} from "lucide-react";

type Range = "week" | "month";

interface DayData {
  dayKey: string;
  label: string;
  revenue: number;
  views: number;
  orders: number;
}

interface OverviewData {
  totalRevenue: number;
  orders: number;
  visits: number;
  customers: number;
  productsSold: number;
  avgOrderValue: number;
  conversionRate: number;
}

function fmtNaira(n: number): string {
  if (typeof n !== "number" || isNaN(n)) return "â‚¦0";
  return `â‚¦${n.toLocaleString("en-NG")}`;
}

function fmtNairaCompact(n: number): string {
  if (typeof n !== "number" || isNaN(n) || n <= 0) return "â‚¦0";
  if (n >= 1000000) return `â‚¦${(n / 1000000).toFixed(1)}M`;
  if (n >= 1000) return `â‚¦${(n / 1000).toFixed(0)}k`;
  return `â‚¦${n.toFixed(0)}`;
}

function fmtNumber(n: number): string {
  if (typeof n !== "number" || isNaN(n)) return "0";
  return n.toLocaleString("en-NG");
}

function fmtPercent(n: number): string {
  if (typeof n !== "number" || isNaN(n)) return "0%";
  return `${n.toFixed(1)}%`;
}

function getShortDayLabel(dateStr: string): string {
  if (!dateStr) return "";
  if (dateStr.startsWith("Wk")) return dateStr;
  
  try {
    const date = new Date(dateStr);
    if (isNaN(date.getTime())) {
      const parts = dateStr.split("-");
      if (parts.length === 3) return parts[2];
      return dateStr.slice(-2);
    }
    return date.toLocaleDateString("en-US", { weekday: "short" });
  } catch {
    return dateStr.slice(-2);
  }
}

function processChartData(rawData: any[], range: Range): DayData[] {
  if (!Array.isArray(rawData) || rawData.length === 0) return [];

  const processed = rawData.map((d) => ({
    dayKey: String(d.dayKey || d.label || Math.random()),
    label: String(d.label || d.dayKey || ""),
    revenue: Math.max(0, Number(d.revenue) || 0),
    views: Math.max(0, Number(d.visits || d.views) || 0),
    orders: Math.max(0, Number(d.orders || d.leads) || 0),
  }));

  if (range === "month" && processed.length > 7) {
    const weeks: DayData[] = [];
    processed.forEach((d, i) => {
      const weekIndex = Math.floor(i / 7);
      if (!weeks[weekIndex]) {
        weeks[weekIndex] = {
          dayKey: `week-${weekIndex + 1}`,
          label: `Wk ${weekIndex + 1}`,
          revenue: 0,
          views: 0,
          orders: 0,
        };
      }
      weeks[weekIndex].revenue += d.revenue;
      weeks[weekIndex].views += d.views;
      weeks[weekIndex].orders += d.orders;
    });
    return weeks;
  }

  return processed;
}

function MetricCard({
  title,
  value,
  subtitle,
  icon: Icon,
  color = "orange",
}: {
  title: string;
  value: string;
  subtitle?: string;
  icon: any;
  color?: "orange" | "green" | "blue" | "purple";
}) {
  const colorClasses = {
    orange: "bg-orange-50 text-orange-600",
    green: "bg-green-50 text-green-600",
    blue: "bg-blue-50 text-blue-600",
    purple: "bg-purple-50 text-purple-600",
  };

  return (
    <div className="bg-white rounded-2xl border border-gray-100 p-4 shadow-sm">
      <div className={`w-10 h-10 rounded-xl ${colorClasses[color]} flex items-center justify-center`}>
        <Icon className="w-5 h-5" />
      </div>
      <div className="mt-3">
        <p className="text-2xl font-black text-gray-900 tracking-tight">{value}</p>
        <p className="text-xs font-medium text-gray-500 mt-1">{title}</p>
        {subtitle && (
          <p className="text-[11px] text-gray-400 mt-0.5">{subtitle}</p>
        )}
      </div>
    </div>
  );
}

function InsightCard({ 
  title, 
  description, 
  type = "info" 
}: { 
  title: string; 
  description: string; 
  type?: "success" | "warning" | "info";
}) {
  const styles = {
    success: "bg-green-50 border-green-100 text-green-800",
    warning: "bg-amber-50 border-amber-100 text-amber-800",
    info: "bg-blue-50 border-blue-100 text-blue-800",
  };

  const icons = {
    success: TrendingUp,
    warning: TrendingDown,
    info: Calendar,
  };

  const Icon = icons[type];

  return (
    <div className={`rounded-xl border p-4 ${styles[type]}`}>
      <div className="flex items-start gap-3">
        <div className="shrink-0 mt-0.5">
          <Icon className="w-4 h-4" />
        </div>
        <div>
          <p className="text-sm font-bold">{title}</p>
          <p className="text-xs mt-1 opacity-80">{description}</p>
        </div>
      </div>
    </div>
  );
}

export default function VendorAnalyticsPage() {
  const router = useRouter();
  const [range, setRange] = useState<Range>("week");
  const [data, setData] = useState<any>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  async function loadAnalytics() {
    setLoading(true);
    setError(null);
    
    try {
      const token = await auth.currentUser?.getIdToken();
      if (!token) {
        throw new Error("Please log in to view analytics.");
      }

      const response = await fetch(`/api/vendor/analytics?range=${range}`, {
        headers: { Authorization: `Bearer ${token}` },
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || "Failed to load analytics data.");
      }

      const json = await response.json();
      setData(json);
    } catch (e: any) {
      setError(e.message || "Something went wrong. Please try again.");
    } finally {
      setLoading(false);
    }
  }

  useEffect(() => {
    loadAnalytics();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [range]);

  const overview: OverviewData = useMemo(() => {
    const ov = data?.overview || {};
    const revenue = Number(ov.totalRevenue) || 0;
    const orders = Number(ov.orders) || 0;
    const visits = Number(ov.visits) || 0;

    return {
      totalRevenue: revenue,
      orders: orders,
      visits: visits,
      customers: Number(ov.customers) || 0,
      productsSold: Number(ov.productsSold) || 0,
      avgOrderValue: orders > 0 ? revenue / orders : 0,
      conversionRate: visits > 0 ? (orders / visits) * 100 : 0,
    };
  }, [data]);

  const chartData = useMemo(() => {
    return processChartData(data?.chartDays || [], range);
  }, [data?.chartDays, range]);

  const revenueChartData = useMemo(() => {
    return chartData.map((d) => ({
      label: getShortDayLabel(d.label),
      value: d.revenue,
    }));
  }, [chartData]);

  const viewsChartData = useMemo(() => {
    return chartData.map((d) => ({
      label: getShortDayLabel(d.label),
      value: d.views,
    }));
  }, [chartData]);

  const ordersChartData = useMemo(() => {
    return chartData.map((d) => ({
      label: getShortDayLabel(d.label),
      value: d.orders,
    }));
  }, [chartData]);

  // Generate insights
  const insights = useMemo(() => {
    const result: { title: string; description: string; type: "success" | "warning" | "info" }[] = [];

    if (overview.conversionRate > 5) {
      result.push({
        title: "Great Conversion Rate",
        description: `${overview.conversionRate.toFixed(1)}% of visitors are making purchases. That's excellent!`,
        type: "success",
      });
    } else if (overview.visits > 10 && overview.conversionRate < 1) {
      result.push({
        title: "Low Conversion Rate",
        description: "Consider improving product descriptions or adding more photos to increase sales.",
        type: "warning",
      });
    }

    if (overview.avgOrderValue > 0) {
      result.push({
        title: "Average Order Value",
        description: `Customers spend ${fmtNaira(overview.avgOrderValue)} on average per order.`,
        type: "info",
      });
    }

    if (overview.visits === 0 && range === "week") {
      result.push({
        title: "No Store Traffic",
        description: "Share your store link on social media to attract customers!",
        type: "warning",
      });
    }

    return result;
  }, [overview, range]);

  const periodLabel = range === "week" ? "Last 7 Days" : "Last 30 Days";

  return (
    <div className="min-h-screen pb-24 bg-gray-50">
      <GradientHeader 
        title="Business Analytics" 
        subtitle="Track your store's performance" 
        showBack={true}
        right={
          <button
            onClick={loadAnalytics}
            disabled={loading}
            className="w-10 h-10 rounded-xl bg-white/20 flex items-center justify-center hover:bg-white/30 transition disabled:opacity-50"
            aria-label="Refresh"
          >
            <RefreshCw className={`w-5 h-5 text-white ${loading ? 'animate-spin' : ''}`} />
          </button>
        }
      />

      <div className="px-4 space-y-4 pt-4">
        {/* Period Selector */}
        <SegmentedControl<Range>
          value={range}
          onChange={setRange}
          options={[
            { value: "week", label: "Last 7 Days" },
            { value: "month", label: "Last 30 Days" },
          ]}
        />

        {/* Error State */}
        {error && (
          <Card className="p-4 bg-red-50 border-red-100">
            <p className="text-red-700 font-medium text-sm">{error}</p>
          </Card>
        )}

        {/* Loading State */}
        {loading && (
          <Card className="p-8 text-center">
            <RefreshCw className="w-8 h-8 text-orange-500 animate-spin mx-auto" />
            <p className="text-gray-500 font-medium mt-3">Loading analytics...</p>
          </Card>
        )}

        {/* Main Content */}
        {!loading && data && (
          <>
            {/* Revenue Hero Card */}
            <div className="rounded-3xl p-6 text-white shadow-lg bg-gradient-to-br from-orange-500 to-orange-600 relative overflow-hidden">
              <div className="absolute top-0 right-0 w-32 h-32 bg-white/10 rounded-full -translate-y-1/2 translate-x-1/2" />
              <div className="absolute bottom-0 left-0 w-24 h-24 bg-white/5 rounded-full translate-y-1/2 -translate-x-1/2" />
              
              <div className="relative z-10">
                <div className="flex items-center gap-2 text-orange-100">
                  <DollarSign className="w-4 h-4" />
                  <span className="text-xs font-bold uppercase tracking-wider">Total Revenue</span>
                </div>
                <p className="text-4xl font-black mt-2 tracking-tight">
                  {fmtNaira(overview.totalRevenue)}
                </p>
                <p className="text-sm text-orange-100 mt-2 font-medium">
                  {periodLabel} â€¢ {overview.orders} order{overview.orders !== 1 ? 's' : ''}
                </p>
              </div>
            </div>

            {/* Key Metrics Grid */}
            <div className="grid grid-cols-2 gap-3">
              <MetricCard
                title="Store Views"
                value={fmtNumber(overview.visits)}
                icon={Eye}
                color="blue"
              />
              <MetricCard
                title="Orders"
                value={fmtNumber(overview.orders)}
                icon={ShoppingCart}
                color="green"
              />
              <MetricCard
                title="Customers"
                value={fmtNumber(overview.customers)}
                icon={Users}
                color="purple"
              />
              <MetricCard
                title="Conversion Rate"
                value={fmtPercent(overview.conversionRate)}
                subtitle={overview.visits > 0 ? `${overview.orders} of ${overview.visits}` : undefined}
                icon={Percent}
                color="orange"
              />
            </div>

            {/* Revenue Chart */}
            <SectionCard title="Revenue Trend" subtitle={`Daily revenue for ${periodLabel.toLowerCase()}`}>
              <AnalyticsChart
                data={revenueChartData}
                color="bg-orange-500"
                height={200}
                formatValue={fmtNairaCompact}
                formatTooltip={(d) => `${d.label}: ${fmtNaira(d.value)}`}
                emptyMessage="No revenue data yet"
              />
            </SectionCard>

            {/* Traffic Chart */}
            <SectionCard title="Store Traffic" subtitle="Visitors to your store">
              <AnalyticsChart
                data={viewsChartData}
                color="bg-blue-500"
                height={160}
                formatValue={(n) => n.toFixed(0)}
                formatTooltip={(d) => `${d.label}: ${d.value} view${d.value !== 1 ? 's' : ''}`}
                emptyMessage="No traffic data yet"
              />
            </SectionCard>

            {/* Orders Chart */}
            <SectionCard title="Orders Received" subtitle="Number of orders per period">
              <AnalyticsChart
                data={ordersChartData}
                color="bg-green-500"
                height={160}
                formatValue={(n) => n.toFixed(0)}
                formatTooltip={(d) => `${d.label}: ${d.value} order${d.value !== 1 ? 's' : ''}`}
                emptyMessage="No orders yet"
              />
            </SectionCard>

            {/* Insights */}
            {insights.length > 0 && (
              <SectionCard title="Insights" subtitle="Tips to improve your store">
                <div className="space-y-3">
                  {insights.map((insight, i) => (
                    <InsightCard key={i} {...insight} />
                  ))}
                </div>
              </SectionCard>
            )}

            {/* Quick Stats Summary */}
            <SectionCard title="Summary" subtitle="Key performance indicators">
              <div className="space-y-0 divide-y divide-gray-100">
                <div className="flex items-center justify-between py-3">
                  <span className="text-sm text-gray-600">Average Order Value</span>
                  <span className="text-sm font-bold text-gray-900">{fmtNaira(overview.avgOrderValue)}</span>
                </div>
                <div className="flex items-center justify-between py-3">
                  <span className="text-sm text-gray-600">Products Sold</span>
                  <span className="text-sm font-bold text-gray-900">{fmtNumber(overview.productsSold)}</span>
                </div>
                <div className="flex items-center justify-between py-3">
                  <span className="text-sm text-gray-600">Unique Customers</span>
                  <span className="text-sm font-bold text-gray-900">{fmtNumber(overview.customers)}</span>
                </div>
                <div className="flex items-center justify-between py-3">
                  <span className="text-sm text-gray-600">Conversion Rate</span>
                  <span className="text-sm font-bold text-gray-900">{fmtPercent(overview.conversionRate)}</span>
                </div>
              </div>
            </SectionCard>
          </>
        )}
      </div>
    </div>
  );
}

// FILE: src/app/vendor/best-sellers/page.tsx
// FILE: src/app/vendor/best-sellers/page.tsx
"use client";

import { useEffect, useMemo, useState } from "react";
import { useRouter } from "next/navigation";
import GradientHeader from "@/components/GradientHeader";
import { Card } from "@/components/Card";
import { Button } from "@/components/ui/Button";
import { IconButton } from "@/components/ui/IconButton";
import { auth } from "@/lib/firebase/client";
import { RefreshCw, TrendingUp, TrendingDown, Flame } from "lucide-react";

function fmtNaira(n: number) {
  try {
    return `â‚¦${Number(n || 0).toLocaleString()}`;
  } catch {
    return `â‚¦${n}`;
  }
}

function fmtDateMs(ms?: number) {
  if (!ms) return "â€”";
  try {
    return new Date(ms).toLocaleString();
  } catch {
    return String(ms);
  }
}

type MetricMode = "revenue" | "units" | "orders";

function Chip({ children, tone }: { children: any; tone: "green" | "orange" | "red" | "gray" }) {
  const cls =
    tone === "green"
      ? "bg-emerald-50 text-emerald-700 border-emerald-100"
      : tone === "orange"
      ? "bg-orange-50 text-orange-700 border-orange-100"
      : tone === "red"
      ? "bg-rose-50 text-rose-700 border-rose-100"
      : "bg-gray-50 text-gray-700 border-gray-100";

  return <span className={`px-2 py-1 rounded-full text-[11px] font-bold border ${cls}`}>{children}</span>;
}

export default function VendorBestSellersPage() {
  const router = useRouter();

  const [loading, setLoading] = useState(true);
  const [msg, setMsg] = useState<string | null>(null);

  const [meta, setMeta] = useState<any>(null);
  const [products, setProducts] = useState<any[]>([]);
  const [dailySeries, setDailySeries] = useState<any[]>([]);
  const [apexInsights, setApexInsights] = useState<any>(null);

  const [days, setDays] = useState<number>(7);
  const [mode, setMode] = useState<MetricMode>("revenue");

  async function authedFetchJson(path: string) {
    const token = await auth.currentUser?.getIdToken();
    const r = await fetch(path, { headers: { Authorization: `Bearer ${token}` } });
    const data = await r.json().catch(() => ({}));
    if (!r.ok) throw new Error(data?.error || data?.code || "Request failed");
    return data;
  }

  async function load(nextDays?: number) {
    try {
      setLoading(true);
      setMsg(null);

      const d = typeof nextDays === "number" ? nextDays : days;

      const data = await authedFetchJson(`/api/vendor/best-sellers?days=${encodeURIComponent(String(d))}&insights=1`);

      setMeta(data?.meta || null);
      setProducts(Array.isArray(data?.products) ? data.products : []);
      setDailySeries(Array.isArray(data?.dailySeries) ? data.dailySeries : []);
      setApexInsights(data?.apexInsights || null);
      setDays(Number(data?.meta?.days || d));
    } catch (e: any) {
      setMsg(e?.message || "Failed to load best-sellers");
      setMeta(null);
      setProducts([]);
      setDailySeries([]);
      setApexInsights(null);
    } finally {
      setLoading(false);
    }
  }

  useEffect(() => {
    load(7);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const planKey = String(meta?.planKey || "FREE").toUpperCase();
  const allowedDays: number[] = Array.isArray(meta?.allowedDays) ? meta.allowedDays : [7];
  const maxRows = Number(meta?.maxRows || 0);
  const maxDays = Number(meta?.maxDays || 0);

  const expansionSuggestion = meta?.bestSellersExpansionSuggestion || null;

  const chartsUnlocked = planKey === "MOMENTUM" || planKey === "APEX";
  const apexUnlocked = planKey === "APEX";

  const series = useMemo(() => {
    const s = Array.isArray(dailySeries) ? dailySeries : [];
    return s.slice(-Math.max(1, Number(days || 7)));
  }, [dailySeries, days]);

  const totals = useMemo(() => {
    const revenueKobo = series.reduce((s, r) => s + Number(r?.revenueKobo || 0), 0);
    const units = series.reduce((s, r) => s + Number(r?.unitsSold || 0), 0);
    const orders = series.reduce((s, r) => s + Number(r?.ordersCount || 0), 0);
    return { revenueKobo, units, orders };
  }, [series]);

  const chartStats = useMemo(() => {
    if (!series.length) return null;

    const getV = (r: any) =>
      mode === "revenue"
        ? Number(r?.revenueKobo || 0)
        : mode === "units"
        ? Number(r?.unitsSold || 0)
        : Number(r?.ordersCount || 0);

    let best = series[0];
    let worst = series[0];

    for (const r of series) {
      if (getV(r) > getV(best)) best = r;
      if (getV(r) < getV(worst)) worst = r;
    }

    const today = series[series.length - 1] || null;
    const yesterday = series.length >= 2 ? series[series.length - 2] : null;

    const tv = today ? getV(today) : 0;
    const yv = yesterday ? getV(yesterday) : 0;
    const diff = tv - yv;

    return {
      bestDayKey: String(best?.dayKey || ""),
      worstDayKey: String(worst?.dayKey || ""),
      todayValue: tv,
      yesterdayValue: yv,
      diff,
    };
  }, [series, mode]);

  const bars = useMemo(() => {
    const getV = (r: any) =>
      mode === "revenue"
        ? Number(r?.revenueKobo || 0)
        : mode === "units"
        ? Number(r?.unitsSold || 0)
        : Number(r?.ordersCount || 0);

    const max = Math.max(1, ...series.map((r) => getV(r)));
    return { max, getV };
  }, [series, mode]);

  function InsightRow({
    name,
    changeNgn,
    recentRevenueNgn,
    prevRevenueNgn,
    isNew,
    tone,
  }: {
    name: string;
    changeNgn: number;
    recentRevenueNgn: number;
    prevRevenueNgn: number;
    isNew?: boolean;
    tone: "green" | "red" | "orange";
  }) {
    const abs = Math.abs(Number(changeNgn || 0));
    const badge =
      tone === "green"
        ? `+${fmtNaira(abs)}`
        : tone === "red"
        ? `-${fmtNaira(abs)}`
        : `${fmtNaira(abs)}`;

    return (
      <div className="rounded-2xl border border-biz-line bg-white p-3">
        <div className="flex items-start justify-between gap-3">
          <div className="min-w-0">
            <p className="text-sm font-extrabold text-biz-ink truncate">{name}</p>
            <p className="text-[11px] text-gray-500 mt-1">
              Recent: <b className="text-biz-ink">{fmtNaira(recentRevenueNgn)}</b> â€¢ Previous:{" "}
              <b className="text-biz-ink">{fmtNaira(prevRevenueNgn)}</b>
            </p>
          </div>

          <div className="text-right shrink-0 flex flex-col items-end gap-1">
            <Chip tone={tone === "green" ? "green" : tone === "red" ? "red" : "orange"}>{badge}</Chip>
            {isNew ? <Chip tone="orange">New</Chip> : null}
          </div>
        </div>

        <p className="text-[11px] text-biz-muted mt-2">
          Tip:{" "}
          {tone === "green"
            ? "Increase stock, promote it, or raise price slightly if demand is strong."
            : "Consider a discount, better photos, or bundling to revive sales."}
        </p>
      </div>
    );
  }

  return (
    <div className="min-h-screen">
      <GradientHeader
        title="Best-selling products"
        subtitle="What customers buy the most"
        showBack={true}
        right={
          <IconButton aria-label="Refresh" onClick={() => load()} disabled={loading}>
            <RefreshCw className="h-5 w-5 text-gray-700" />
          </IconButton>
        }
      />

      <div className="px-4 pb-24 space-y-3">
        {msg ? (
          <Card className="p-4 text-red-700">
            {msg}
            {String(msg || "").toLowerCase().includes("locked") ? (
              <div className="mt-2">
                <Button size="sm" onClick={() => router.push("/vendor/subscription")}>
                  Upgrade
                </Button>
              </div>
            ) : null}
          </Card>
        ) : null}

        <Card className="p-4">
          <div className="flex items-start justify-between gap-3">
            <div>
              <p className="font-extrabold text-biz-ink">Overview</p>
              <p className="text-xs text-biz-muted mt-1">
                Plan: <b className="text-biz-ink">{planKey}</b> â€¢ Showing up to{" "}
                <b className="text-biz-ink">{maxRows || "â€”"}</b>
              </p>
              <p className="text-[11px] text-gray-500 mt-1">
                Time range: last <b>{days}</b> days (max: <b>{maxDays || "â€”"}</b>)
              </p>

              <p className="text-[11px] text-gray-500 mt-2">
                Total revenue: <b className="text-biz-ink">{fmtNaira(totals.revenueKobo / 100)}</b> â€¢ Units:{" "}
                <b className="text-biz-ink">{totals.units}</b> â€¢ Orders:{" "}
                <b className="text-biz-ink">{totals.orders}</b>
              </p>
            </div>

            <Button variant="secondary" size="sm" onClick={() => load()} loading={loading}>
              Refresh
            </Button>
          </div>

          <div className="mt-3 flex flex-wrap gap-2">
            {allowedDays.map((d) => (
              <Button
                key={d}
                size="sm"
                variant={days === d ? "primary" : "secondary"}
                onClick={() => load(d)}
                disabled={loading}
              >
                Last {d} days
              </Button>
            ))}
          </div>
        </Card>

        {expansionSuggestion ? (
          <Card className="p-4">
            <p className="font-extrabold text-biz-ink">Want more?</p>
            <p className="text-[11px] text-biz-muted mt-1">{String(expansionSuggestion?.title || "")}</p>
            <div className="mt-2 flex gap-2">
              <Button size="sm" onClick={() => router.push(String(expansionSuggestion?.url || "/vendor/purchases"))}>
                Buy expansion
              </Button>
              <Button size="sm" variant="secondary" onClick={() => router.push("/vendor/subscription")}>
                Upgrade plan
              </Button>
            </div>
          </Card>
        ) : null}

        {chartsUnlocked ? (
          <Card className="p-4">
            <div className="flex items-start justify-between gap-3">
              <div>
                <p className="font-extrabold text-biz-ink">Daily performance</p>
                <p className="text-[11px] text-biz-muted mt-1">
                  Switch between revenue, units sold, and orders. (No chart library)
                </p>
              </div>

              <div className="flex gap-2">
                <Button size="sm" variant={mode === "revenue" ? "primary" : "secondary"} onClick={() => setMode("revenue")}>
                  Revenue
                </Button>
                <Button size="sm" variant={mode === "units" ? "primary" : "secondary"} onClick={() => setMode("units")}>
                  Units
                </Button>
                <Button size="sm" variant={mode === "orders" ? "primary" : "secondary"} onClick={() => setMode("orders")}>
                  Orders
                </Button>
              </div>
            </div>

            {chartStats ? (
              <div className="mt-3 grid grid-cols-2 gap-2">
                <Card variant="soft" className="p-3">
                  <p className="text-[11px] text-biz-muted">Best day</p>
                  <p className="text-sm font-extrabold text-biz-ink mt-1">{chartStats.bestDayKey || "â€”"}</p>
                </Card>
                <Card variant="soft" className="p-3">
                  <p className="text-[11px] text-biz-muted">Worst day</p>
                  <p className="text-sm font-extrabold text-biz-ink mt-1">{chartStats.worstDayKey || "â€”"}</p>
                </Card>

                <Card variant="soft" className="p-3">
                  <p className="text-[11px] text-biz-muted">Today vs yesterday</p>
                  <p className="text-sm font-extrabold mt-1">
                    <span className={chartStats.diff >= 0 ? "text-emerald-700" : "text-rose-700"}>
                      {chartStats.diff >= 0 ? "+" : ""}
                      {mode === "revenue" ? fmtNaira(chartStats.diff / 100) : String(chartStats.diff)}
                    </span>
                  </p>
                </Card>

                <Card variant="soft" className="p-3">
                  <p className="text-[11px] text-biz-muted">Current max</p>
                  <p className="text-sm font-extrabold text-biz-ink mt-1">
                    {mode === "revenue" ? fmtNaira(bars.max / 100) : String(bars.max)}
                  </p>
                </Card>
              </div>
            ) : null}

            {series.length === 0 ? (
              <p className="text-sm text-biz-muted mt-3">No chart data yet.</p>
            ) : (
              <div className="mt-4 flex items-end gap-2 h-28">
                {series.map((d: any) => {
                  const v = bars.getV(d);
                  const h = Math.max(6, Math.round((v / bars.max) * 100));
                  const label = String(d.dayKey || "").slice(8, 10);

                  const title =
                    mode === "revenue"
                      ? `${d.dayKey} â€¢ Revenue: ${fmtNaira(Number(d.revenueKobo || 0) / 100)}`
                      : mode === "units"
                      ? `${d.dayKey} â€¢ Units: ${Number(d.unitsSold || 0)}`
                      : `${d.dayKey} â€¢ Orders: ${Number(d.ordersCount || 0)}`;

                  return (
                    <div key={d.dayKey} className="flex-1 flex flex-col items-center justify-end gap-2">
                      <div
                        className="w-full rounded-xl bg-gradient-to-b from-biz-accent to-biz-accent2"
                        style={{ height: `${h}%` }}
                        title={title}
                      />
                      <span className="text-[10px] text-gray-500">{label}</span>
                    </div>
                  );
                })}
              </div>
            )}
          </Card>
        ) : (
          <Card className="p-4">
            <p className="font-extrabold text-biz-ink">Charts locked</p>
            <p className="text-[11px] text-biz-muted mt-1">
              Daily charts are available on <b>Momentum</b> and <b>Apex</b>.
            </p>
            <div className="mt-2">
              <Button size="sm" onClick={() => router.push("/vendor/subscription")}>
                Upgrade
              </Button>
            </div>
          </Card>
        )}

        {apexUnlocked ? (
          apexInsights ? (
            <>
              <Card className="p-4">
                <div className="flex items-start justify-between gap-3">
                  <div>
                    <p className="font-extrabold text-biz-ink">APEX insights</p>
                    <p className="text-[11px] text-biz-muted mt-1">
                      Comparing <b>{apexInsights.prevLabel}</b> vs <b>{apexInsights.recentLabel}</b>
                    </p>
                  </div>
                  <Chip tone="green">APEX</Chip>
                </div>
              </Card>

              <Card className="p-4">
                <div className="flex items-center gap-2">
                  <TrendingUp className="h-5 w-5 text-emerald-700" />
                  <p className="font-extrabold text-biz-ink">Rising products</p>
                </div>
                <p className="text-[11px] text-biz-muted mt-1">Products whose revenue increased in the last 7 days.</p>

                <div className="mt-3 space-y-2">
                  {(apexInsights?.risers || []).length === 0 ? (
                    <p className="text-sm text-biz-muted">No risers yet.</p>
                  ) : (
                    apexInsights.risers.map((x: any) => (
                      <InsightRow
                        key={x.productId}
                        name={x.name}
                        changeNgn={Number(x.changeNgn || 0)}
                        recentRevenueNgn={Number(x.recentRevenueNgn || 0)}
                        prevRevenueNgn={Number(x.prevRevenueNgn || 0)}
                        isNew={!!x.isNew}
                        tone="green"
                      />
                    ))
                  )}
                </div>
              </Card>

              <Card className="p-4">
                <div className="flex items-center gap-2">
                  <TrendingDown className="h-5 w-5 text-rose-700" />
                  <p className="font-extrabold text-biz-ink">Products dropping</p>
                </div>
                <p className="text-[11px] text-biz-muted mt-1">
                  Products losing revenue compared to the previous 7 days.
                </p>

                <div className="mt-3 space-y-2">
                  {(apexInsights?.droppers || []).length === 0 ? (
                    <p className="text-sm text-biz-muted">No droppers yet.</p>
                  ) : (
                    apexInsights.droppers.map((x: any) => (
                      <InsightRow
                        key={x.productId}
                        name={x.name}
                        changeNgn={Number(x.changeNgn || 0)}
                        recentRevenueNgn={Number(x.recentRevenueNgn || 0)}
                        prevRevenueNgn={Number(x.prevRevenueNgn || 0)}
                        tone="red"
                      />
                    ))
                  )}
                </div>
              </Card>

              <Card className="p-4">
                <div className="flex items-center gap-2">
                  <Flame className="h-5 w-5 text-orange-700" />
                  <p className="font-extrabold text-biz-ink">New hot products</p>
                </div>
                <p className="text-[11px] text-biz-muted mt-1">
                  Products that sold this week but did not sell last week.
                </p>

                <div className="mt-3 space-y-2">
                  {(apexInsights?.newHot || []).length === 0 ? (
                    <p className="text-sm text-biz-muted">No new hot products yet.</p>
                  ) : (
                    apexInsights.newHot.map((x: any) => (
                      <div key={x.productId} className="rounded-2xl border border-biz-line bg-white p-3">
                        <div className="flex items-start justify-between gap-3">
                          <div className="min-w-0">
                            <p className="text-sm font-extrabold text-biz-ink truncate">{x.name}</p>
                            <p className="text-[11px] text-gray-500 mt-1">
                              Revenue: <b className="text-biz-ink">{fmtNaira(Number(x.revenueNgn || 0))}</b> â€¢ Units:{" "}
                              <b className="text-biz-ink">{Number(x.units || 0)}</b>
                            </p>
                          </div>
                          <Chip tone="orange">New</Chip>
                        </div>
                        <p className="text-[11px] text-biz-muted mt-2">
                          Tip: promote it or restock early so you donâ€™t miss the trend.
                        </p>
                      </div>
                    ))
                  )}
                </div>
              </Card>
            </>
          ) : (
            <Card className="p-4">
              <p className="font-extrabold text-biz-ink">APEX insights</p>
              <p className="text-[11px] text-biz-muted mt-1">Not enough data yet to generate insights.</p>
            </Card>
          )
        ) : null}

        {loading ? <Card className="p-4">Loadingâ€¦</Card> : null}

        {!loading && products.length === 0 ? (
          <Card className="p-5 text-center">
            <p className="text-base font-extrabold text-biz-ink">No sales data yet</p>
            <p className="text-sm text-biz-muted mt-2">Best-sellers will appear after paid orders come in.</p>
          </Card>
        ) : null}

        <div className="space-y-2">
          {products.map((p, idx) => (
            <Card key={p.productId || idx} className="p-4">
              <div className="flex items-start justify-between gap-3">
                <div className="min-w-0">
                  <p className="font-extrabold text-biz-ink truncate">{p.name || "Product"}</p>
                  <p className="text-[11px] text-gray-500 mt-1 break-all">
                    Product ID: <b className="text-biz-ink">{p.productId}</b>
                  </p>
                  <p className="text-[11px] text-gray-500 mt-2">
                    Units sold: <b className="text-biz-ink">{Number(p.unitsSold || 0)}</b>
                  </p>
                  <p className="text-[11px] text-gray-500 mt-1">
                    Last sold: <b className="text-biz-ink">{fmtDateMs(Number(p.lastSoldAtMs || 0))}</b>
                  </p>
                </div>

                <div className="text-right shrink-0">
                  <p className="text-sm font-extrabold text-biz-ink">{fmtNaira(Number(p.revenueNgn || 0))}</p>
                  <p className="text-[11px] text-gray-500 mt-1">Revenue</p>
                </div>
              </div>
            </Card>
          ))}
        </div>
      </div>
    </div>
  );
}

// FILE: src/app/vendor/coupon/page.tsx
"use client";

import { useEffect, useMemo, useState } from "react";
import GradientHeader from "@/components/GradientHeader";
import { Card } from "@/components/Card";
import { Button } from "@/components/ui/Button";
import { Input } from "@/components/ui/Input";
import { SectionCard } from "@/components/ui/SectionCard";
import { SegmentedControl } from "@/components/ui/SegmentedControl";
import { auth } from "@/lib/firebase/client";
import { useRouter } from "next/navigation";

type CouponType = "percent" | "fixed";

function fmtNairaFromKobo(kobo: number) {
  const n = Number(kobo || 0) / 100;
  try {
    return `â‚¦${n.toLocaleString()}`;
  } catch {
    return `â‚¦${n}`;
  }
}

function clampInt(n: any, min: number, max: number) {
  const v = Math.floor(Number(n));
  if (!Number.isFinite(v)) return min;
  return Math.max(min, Math.min(max, v));
}

function toMsDateInput(v: string) {
  if (!v) return null;
  const d = new Date(v + "T00:00:00");
  const ms = d.getTime();
  return Number.isFinite(ms) ? ms : null;
}

export default function VendorCouponsPage() {
  const router = useRouter();

  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [msg, setMsg] = useState<string | null>(null);

  const [me, setMe] = useState<any>(null);
  const [coupons, setCoupons] = useState<any[]>([]);

  // create/update form
  const [code, setCode] = useState("");
  const [type, setType] = useState<CouponType>("percent");

  const [percent, setPercent] = useState(10);
  const [amountOffNgn, setAmountOffNgn] = useState(1000);

  const [minOrderNgn, setMinOrderNgn] = useState(0);
  const [maxDiscountNgn, setMaxDiscountNgn] = useState(0);
  const [usageLimitTotal, setUsageLimitTotal] = useState<number>(0);

  const [startsAt, setStartsAt] = useState<string>("");
  const [endsAt, setEndsAt] = useState<string>("");

  const [active, setActive] = useState(true);

  async function authedFetch(path: string, init?: RequestInit) {
    const token = await auth.currentUser?.getIdToken();
    const r = await fetch(path, {
      ...init,
      headers: { ...(init?.headers || {}), Authorization: `Bearer ${token}` },
    });
    const data = await r.json().catch(() => ({}));
    if (!r.ok) throw new Error(data?.error || data?.code || "Request failed");
    return data;
  }

  async function load() {
    setLoading(true);
    setMsg(null);
    try {
      const token = await auth.currentUser?.getIdToken();
      const rMe = await fetch("/api/me", { headers: { Authorization: `Bearer ${token}` } });
      const meData = await rMe.json().catch(() => ({}));
      if (!rMe.ok) throw new Error(meData?.error || "Failed to load profile");
      setMe(meData.me);

      const data = await authedFetch("/api/vendor/coupons");
      setCoupons(Array.isArray(data.coupons) ? data.coupons : []);
    } catch (e: any) {
      setMsg(e?.message || "Failed");
      setCoupons([]);
    } finally {
      setLoading(false);
    }
  }

  useEffect(() => {
    load();
  }, []);

  const isOwner = useMemo(() => String(me?.role || "") === "owner", [me]);

  async function saveCoupon() {
    setSaving(true);
    setMsg(null);
    try {
      const payload: any = {
        code: code.trim().toUpperCase(),
        active,
        type,
        percent: type === "percent" ? clampInt(percent, 1, 90) : undefined,
        amountOffKobo: type === "fixed" ? Math.max(0, Math.floor(amountOffNgn * 100)) : undefined,
        minOrderKobo: Math.max(0, Math.floor(minOrderNgn * 100)),
        maxDiscountKobo: maxDiscountNgn > 0 ? Math.floor(maxDiscountNgn * 100) : 0,
        usageLimitTotal: usageLimitTotal > 0 ? usageLimitTotal : null,
        startsAtMs: startsAt ? toMsDateInput(startsAt) : null,
        endsAtMs: endsAt ? toMsDateInput(endsAt) : null,
      };

      await authedFetch("/api/vendor/coupons", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });

      setMsg("Saved.");
      setTimeout(() => setMsg(null), 1200);
      setCode("");
      await load();
    } catch (e: any) {
      setMsg(e?.message || "Failed");
    } finally {
      setSaving(false);
    }
  }

  async function toggleActive(c: any) {
    setMsg(null);
    try {
      const payload: any = {
        code: String(c.codeUpper || c.code || "").toUpperCase(),
        active: !(c.active === false),
        type: String(c.type || "percent"),
        percent: c.percent ?? 10,
        amountOffKobo: c.amountOffKobo ?? 0,
        minOrderKobo: c.minOrderKobo ?? 0,
        maxDiscountKobo: c.maxDiscountKobo ?? 0,
        usageLimitTotal: c.usageLimitTotal ?? null,
        startsAtMs: c.startsAtMs ?? null,
        endsAtMs: c.endsAtMs ?? null,
      };

      await authedFetch("/api/vendor/coupons", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });

      await load();
    } catch (e: any) {
      setMsg(e?.message || "Failed");
    }
  }

  return (
    <div className="min-h-screen">
      <GradientHeader title="Coupon codes" subtitle="Discount codes for checkout" showBack={true} />

      <div className="px-4 pb-24 space-y-3">
        {loading ? <Card className="p-4">Loadingâ€¦</Card> : null}
        {msg ? <Card className="p-4">{msg}</Card> : null}

        {!loading && !isOwner ? (
          <Card variant="soft" className="p-5">
            <p className="text-sm font-extrabold text-biz-ink">Owner only</p>
            <p className="text-
