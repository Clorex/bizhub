===== FILE: src/components/vendor/ImageUploader.tsx =====
// FILE: src/components/vendor/ImageUploader.tsx
"use client";

import { useEffect, useMemo, useRef, useState } from "react";
import { auth } from "@/lib/firebase/client";
import { Button } from "@/components/ui/Button";
import { cloudinaryOptimizedUrl } from "@/lib/cloudinary/url";
import type { CoverAspectKey } from "@/lib/products/coverAspect";

type SignedPayload = {
  ok: boolean;
  cloudName: string;
  apiKey: string;
  folder: string;
  timestamp: number;
  signature: string;
  error?: string;
};

type DraftItem = {
  id: string;
  file: File;
  previewUrl: string;

  status: "ready" | "uploading" | "uploaded" | "error";
  progress: number; // internal only (UI uses minimal spinner)
  error?: string;

  uploadedUrl?: string;
};

function uid() {
  try {
    const c: any = globalThis.crypto;
    if (c?.randomUUID) return c.randomUUID();
  } catch {}
  return `img_${Date.now()}_${Math.random().toString(16).slice(2)}`;
}

function isImageFile(f: File) {
  return !!f?.type?.startsWith("image/");
}

function sleep(ms: number) {
  return new Promise((r) => setTimeout(r, ms));
}

async function canvasToBlob(canvas: HTMLCanvasElement, type: string, quality?: number) {
  return new Promise<Blob>((resolve, reject) => {
    canvas.toBlob((b) => (b ? resolve(b) : reject(new Error("Failed to create image blob"))), type, quality);
  });
}

function downscaleCanvas(src: HTMLCanvasElement, maxDim = 1600) {
  const w = src.width;
  const h = src.height;
  const max = Math.max(w, h);
  if (max <= maxDim) return src;

  const scale = maxDim / max;
  const tw = Math.max(1, Math.round(w * scale));
  const th = Math.max(1, Math.round(h * scale));

  const out = document.createElement("canvas");
  out.width = tw;
  out.height = th;

  const ctx = out.getContext("2d");
  if (!ctx) return src;

  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = "high";
  ctx.drawImage(src, 0, 0, tw, th);
  return out;
}

async function fileToImageBitmap(file: File): Promise<ImageBitmap | null> {
  try {
    if ("createImageBitmap" in window) {
      // @ts-ignore
      return await createImageBitmap(file);
    }
  } catch {}
  return null;
}

async function fileToHtmlImage(file: File): Promise<HTMLImageElement> {
  const url = URL.createObjectURL(file);
  try {
    const img = new Image();
    img.decoding = "async";
    img.loading = "eager";
    await new Promise<void>((resolve, reject) => {
      img.onload = () => resolve();
      img.onerror = () => reject(new Error("Failed to load image"));
      img.src = url;
    });
    return img;
  } finally {
    try {
      URL.revokeObjectURL(url);
    } catch {}
  }
}

async function compressIfLarge(file: File): Promise<File> {
  if (!isImageFile(file)) return file;
  if (file.size < 1_000_000) return file;

  const bmp = await fileToImageBitmap(file);
  if (bmp) {
    const c = document.createElement("canvas");
    c.width = bmp.width;
    c.height = bmp.height;

    const ctx = c.getContext("2d");
    if (!ctx) return file;

    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = "high";
    ctx.drawImage(bmp, 0, 0);

    const scaled = downscaleCanvas(c, 1600);
    const blob = await canvasToBlob(scaled, "image/jpeg", 0.86);

    const base = (file.name || "image").replace(/\.[a-z0-9]+$/i, "");
    return new File([blob], `${base}-optimized.jpg`, { type: "image/jpeg" });
  }

  return file;
}

async function cropFileToCenteredSquare(file: File) {
  const bmp = await fileToImageBitmap(file);

  let iw = 0;
  let ih = 0;

  if (bmp) {
    iw = bmp.width;
    ih = bmp.height;
  } else {
    const img = await fileToHtmlImage(file);
    iw = img.naturalWidth;
    ih = img.naturalHeight;
  }

  if (!iw || !ih) throw new Error("Invalid image dimensions");

  const side = Math.max(1, Math.min(iw, ih));
  const sx = Math.round((iw - side) / 2);
  const sy = Math.round((ih - side) / 2);

  const c = document.createElement("canvas");
  c.width = side;
  c.height = side;

  const ctx = c.getContext("2d");
  if (!ctx) throw new Error("Canvas not supported");

  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = "high";

  if (bmp) {
    ctx.drawImage(bmp, sx, sy, side, side, 0, 0, side, side);
  } else {
    const img = await fileToHtmlImage(file);
    ctx.drawImage(img, sx, sy, side, side, 0, 0, side, side);
  }

  const scaled = downscaleCanvas(c, 1600);
  const blob = await canvasToBlob(scaled, "image/jpeg", 0.86);

  const baseName = (file.name || "image").replace(/\.[a-z0-9]+$/i, "");
  return new File([blob], `${baseName}-square.jpg`, { type: "image/jpeg" });
}

async function getSigned(folderBase: string): Promise<SignedPayload> {
  const token = await auth.currentUser?.getIdToken();
  if (!token) throw new Error("Not logged in");

  const r = await fetch("/api/uploads/cloudinary/sign", {
    method: "POST",
    headers: { "Content-Type": "application/json", Authorization: `Bearer ${token}` },
    body: JSON.stringify({ folderBase }),
  });

  const data = (await r.json().catch(() => ({}))) as SignedPayload;
  if (!r.ok || !data?.ok) throw new Error(data?.error || "Failed to sign upload");
  return data;
}

function uploadOneToCloudinary(params: {
  cloudName: string;
  apiKey: string;
  folder: string;
  timestamp: number;
  signature: string;
  file: File;
  onProgress: (pct: number) => void;
}) {
  const url = `https://api.cloudinary.com/v1_1/${params.cloudName}/image/upload`;

  return new Promise<string>((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    const form = new FormData();

    form.append("file", params.file);
    form.append("api_key", params.apiKey);
    form.append("timestamp", String(params.timestamp));
    form.append("signature", params.signature);
    form.append("folder", params.folder);

    xhr.upload.onprogress = (e) => {
      if (!e.lengthComputable) return;
      const pct = Math.round((e.loaded / e.total) * 100);
      params.onProgress(Math.max(0, Math.min(100, pct)));
    };

    xhr.onerror = () => reject(new Error("Network error uploading to Cloudinary"));
    xhr.onabort = () => reject(new Error("Upload aborted"));

    xhr.onload = () => {
      try {
        const json = JSON.parse(xhr.responseText || "{}");
        if (xhr.status >= 200 && xhr.status < 300) {
          const secureUrl = String(json.secure_url || "");
          if (!secureUrl) return reject(new Error("Upload succeeded but no secure_url returned"));
          return resolve(secureUrl);
        }
        reject(new Error(String(json?.error?.message || "Cloudinary upload failed")));
      } catch (e: any) {
        reject(new Error(e?.message || "Failed to parse Cloudinary response"));
      }
    };

    xhr.open("POST", url);
    xhr.send(form);
  });
}

// Cache signed payload briefly
const SIGN_TTL_MS = 2 * 60 * 1000;

export function ImageUploader(props: {
  label?: string;
  value?: string[];
  onChange?: (urls: string[]) => void;
  onUploaded?: (urls: string[]) => void;
  multiple?: boolean;
  max?: number;
  folderBase?: string;
  disabled?: boolean;

  // Kept only for compatibility with existing callers; no longer used (square-only enforced)
  aspectKey?: CoverAspectKey;
  onAspectKeyChange?: (k: CoverAspectKey) => void;
  allowFreeAspect?: boolean;
}) {
  const {
    label = "Product images",
    value,
    onChange,
    onUploaded,
    multiple = true,
    max = 10,
    folderBase = "bizhub/uploads",
    disabled = false,
  } = props;

  const [drafts, setDrafts] = useState<DraftItem[]>([]);
  const draftsRef = useRef<DraftItem[]>([]);
  useEffect(() => {
    draftsRef.current = drafts;
  }, [drafts]);

  const [err, setErr] = useState<string | null>(null);

  const inputRef = useRef<HTMLInputElement | null>(null);

  const uploadedUrls: string[] = Array.isArray(value) ? value : [];
  const uploadedRef = useRef<string[]>(uploadedUrls);
  useEffect(() => {
    uploadedRef.current = uploadedUrls;
  }, [uploadedUrls]);

  const totalCount = uploadedUrls.length + drafts.length;
  const remainingSlots = Math.max(0, max - totalCount);

  const uploadingAny = useMemo(() => drafts.some((d) => d.status === "uploading"), [drafts]);

  const signedCacheRef = useRef<{ at: number; payload: SignedPayload } | null>(null);

  // cleanup object URLs
  useEffect(() => {
    return () => {
      for (const d of draftsRef.current) {
        try {
          URL.revokeObjectURL(d.previewUrl);
        } catch {}
      }
    };
  }, []);

  function setUploaded(next: string[]) {
    uploadedRef.current = next;
    onChange?.(next);
  }

  async function getSignedCached() {
    const cached = signedCacheRef.current;
    const now = Date.now();
    if (cached && now - cached.at < SIGN_TTL_MS) return cached.payload;

    const payload = await getSigned(folderBase);
    signedCacheRef.current = { at: now, payload };
    return payload;
  }

  function addFiles(files: FileList | null) {
    if (!files || files.length === 0) return;
    setErr(null);

    const picked = Array.from(files);

    for (const f of picked) {
      if (!isImageFile(f)) {
        setErr("Only image files are allowed.");
        return;
      }
    }

    if (remainingSlots <= 0) {
      setErr(`You can only upload up to ${max} images.`);
      return;
    }

    const slice = picked.slice(0, remainingSlots);

    const newDrafts: DraftItem[] = slice.map((file) => ({
      id: uid(),
      file,
      previewUrl: URL.createObjectURL(file),
      status: "ready",
      progress: 0,
    }));

    setDrafts((prev) => [...prev, ...newDrafts]);

    if (inputRef.current) inputRef.current.value = "";

    if (picked.length > slice.length) {
      setErr(`Only ${remainingSlots} slot(s) left. Extra images were ignored.`);
    }
  }

  function removeDraft(id: string) {
    setDrafts((prev) => {
      const d = prev.find((x) => x.id === id);
      if (d) {
        try {
          URL.revokeObjectURL(d.previewUrl);
        } catch {}
      }
      return prev.filter((x) => x.id !== id);
    });
  }

  function removeUploaded(url: string) {
    setUploaded(uploadedRef.current.filter((u) => u !== url));
  }

  function makeCover(url: string) {
    const cur = uploadedRef.current;
    setUploaded([url, ...cur.filter((u) => u !== url)]);
  }

  async function uploadDraft(id: string) {
    const d0 = draftsRef.current.find((d) => d.id === id);
    if (!d0) return;
    if (d0.status === "uploading") return;

    if (uploadedRef.current.length >= max) {
      setErr(`You can only upload up to ${max} images.`);
      return;
    }

    setErr(null);
    setDrafts((prev) => prev.map((d) => (d.id === id ? { ...d, status: "uploading", progress: 0 } : d)));

    let lastErr: any = null;

    for (let attempt = 1; attempt <= 3; attempt++) {
      try {
        const signed = await getSignedCached();

        // Enforce square output (no cropper UI)
        const squared = await cropFileToCenteredSquare(d0.file);
        const fileToSend = await compressIfLarge(squared);

        const url = await uploadOneToCloudinary({
          cloudName: signed.cloudName,
          apiKey: signed.apiKey,
          folder: signed.folder,
          timestamp: signed.timestamp,
          signature: signed.signature,
          file: fileToSend,
          onProgress: (pct) => {
            setDrafts((prev) => prev.map((d) => (d.id === id ? { ...d, progress: pct } : d)));
          },
        });

        setDrafts((prev) =>
          prev.map((d) => (d.id === id ? { ...d, status: "uploaded", progress: 100, uploadedUrl: url } : d))
        );

        const next = [...uploadedRef.current, url].slice(0, max);
        setUploaded(next);
        onUploaded?.([url]);
        return;
      } catch (e: any) {
        lastErr = e;
        if (attempt < 3) {
          await sleep(400 * attempt);
          continue;
        }
      }
    }

    setDrafts((prev) =>
      prev.map((d) =>
        d.id === id ? { ...d, status: "error", progress: 0, error: lastErr?.message || "Upload failed" } : d
      )
    );
  }

  async function runPool(ids: string[], concurrency: number) {
    const q = [...ids];
    const workers = Array.from({ length: Math.max(1, concurrency) }, async () => {
      while (q.length) {
        if (uploadedRef.current.length >= max) return;
        const id = q.shift();
        if (!id) return;
        // eslint-disable-next-line no-await-in-loop
        await uploadDraft(id);
      }
    });
    await Promise.all(workers);
  }

  async function uploadAll() {
    const queue = draftsRef.current
      .filter((d) => d.status === "ready" || d.status === "error")
      .map((d) => d.id);
    await runPool(queue, 2);
  }

  return (
    <div className="pb-2">
      <div className="flex items-start justify-between gap-3">
        <div>
          <label className="block text-sm font-bold text-biz-ink">{label}</label>
          <p className="mt-1 text-[11px] text-biz-muted">Images are automatically center-cropped to square (1:1).</p>
        </div>

        <div className="shrink-0 text-right">
          <p className="text-[11px] text-biz-muted">
            {uploadedUrls.length}/{max} uploaded
          </p>
        </div>
      </div>

      <div className="mt-3 grid grid-cols-1 sm:grid-cols-2 gap-2">
        <input
          ref={inputRef}
          className="hidden"
          type="file"
          accept="image/*"
          multiple={multiple}
          onChange={(e) => addFiles(e.target.files)}
          disabled={disabled || remainingSlots <= 0}
        />

        <Button
          variant="secondary"
          onClick={() => inputRef.current?.click()}
          disabled={disabled || remainingSlots <= 0 || uploadingAny}
        >
          Add photo
        </Button>

        <Button onClick={uploadAll} disabled={disabled || uploadingAny || drafts.every((d) => d.status === "uploaded")}>
          Upload all
        </Button>
      </div>

      <div className="mt-2 flex items-center justify-between gap-3">
        {remainingSlots <= 0 ? (
          <span className="text-[11px] font-bold text-orange-700">Max reached</span>
        ) : (
          <span className="text-[11px] text-biz-muted">{remainingSlots} slot(s) left</span>
        )}
      </div>

      {err ? <p className="mt-2 text-xs text-red-700">{err}</p> : null}

      {/* Uploaded */}
      {uploadedUrls.length ? (
        <div className="mt-4">
          <p className="text-xs font-bold text-biz-ink">Uploaded</p>
          <div className="mt-2 grid grid-cols-3 gap-2">
            {uploadedUrls.map((u, idx) => {
              const thumb = cloudinaryOptimizedUrl(u, { w: 320, h: 320 });
              return (
                <div key={u} className="rounded-2xl border border-biz-line overflow-hidden bg-white">
                  {/* eslint-disable-next-line @next/next/no-img-element */}
                  <img src={thumb} alt="Uploaded" className="aspect-square w-full object-cover" loading="lazy" decoding="async" />

                  <div className="p-2 space-y-2">
                    {idx === 0 ? (
                      <p className="text-[11px] font-extrabold text-emerald-700">Cover</p>
                    ) : (
                      <button className="text-[11px] font-bold text-biz-accent" onClick={() => makeCover(u)}>
                        Make cover
                      </button>
                    )}

                    <button className="text-[11px] font-bold text-red-600" onClick={() => removeUploaded(u)}>
                      Remove
                    </button>
                  </div>
                </div>
              );
            })}
          </div>
        </div>
      ) : null}

      {/* Drafts */}
      {drafts.length ? (
        <div className="mt-4">
          <p className="text-xs font-bold text-biz-ink">Selected</p>

          <div className="mt-2 grid grid-cols-3 gap-2">
            {drafts.map((d) => (
              <div key={d.id} className="rounded-2xl border border-biz-line overflow-hidden bg-white">
                {/* eslint-disable-next-line @next/next/no-img-element */}
                <img src={d.previewUrl} alt="Selected" className="aspect-square w-full object-cover" />

                <div className="p-2 space-y-2">
                  {d.status !== "uploaded" ? (
                    <button
                      className="text-[11px] font-bold text-gray-700 disabled:opacity-50"
                      onClick={() => removeDraft(d.id)}
                      disabled={disabled || d.status === "uploading"}
                    >
                      Remove
                    </button>
                  ) : null}

                  {d.status === "ready" ? (
                    <button
                      className="w-full py-2 rounded-xl text-[11px] font-extrabold bg-biz-cream text-biz-ink disabled:opacity-50"
                      onClick={() => uploadDraft(d.id)}
                      disabled={disabled || uploadingAny || uploadedUrls.length >= max}
                    >
                      Upload
                    </button>
                  ) : null}

                  {d.status === "uploading" ? (
                    <div className="flex items-center gap-2">
                      <span
                        className="inline-block h-4 w-4 rounded-full border-2 border-biz-line border-t-biz-accent animate-spin"
                        aria-label="Uploading"
                      />
                      <p className="text-[11px] text-biz-muted">Uploadingâ€¦</p>
                    </div>
                  ) : null}

                  {d.status === "uploaded" ? <p className="text-[11px] font-bold text-emerald-700">Uploaded</p> : null}

                  {d.status === "error" ? (
                    <div>
                      <p className="text-[11px] font-bold text-red-700">{d.error || "Upload failed"}</p>
                      <button
                        className="mt-1 w-full py-2 rounded-xl text-[11px] font-extrabold bg-white border border-biz-line"
                        onClick={() => uploadDraft(d.id)}
                        disabled={disabled || uploadingAny}
                      >
                        Retry
                      </button>
                    </div>
                  ) : null}
                </div>
              </div>
            ))}
          </div>
        </div>
      ) : null}
    </div>
  );
}
===== END FILE: src/components/vendor/ImageUploader.tsx =====

===== FILE: src/app/vendor/products/new/page.tsx =====
// FILE: src/app/vendor/products/new/page.tsx
"use client";

import { useEffect, useMemo, useState } from "react";
import { auth } from "@/lib/firebase/client";
import GradientHeader from "@/components/GradientHeader";
import { Card } from "@/components/Card";
import { SectionCard } from "@/components/ui/SectionCard";
import { useRouter } from "next/navigation";
import { ImageUploader } from "@/components/vendor/ImageUploader";
import { OptionGroup, VariationBuilder } from "@/components/vendor/VariationBuilder";
import { Button } from "@/components/ui/Button";
import { Input } from "@/components/ui/Input";
import { Chip } from "@/components/ui/Chip";
import { toast } from "@/lib/ui/toast";
import { cn } from "@/lib/cn";
import { type CoverAspectKey, normalizeCoverAspect } from "@/lib/products/coverAspect";
import { MARKET_CATEGORIES, suggestCategoriesFromText, type MarketCategoryKey } from "@/lib/search/marketTaxonomy";
import { formatMoneyNGN } from "@/lib/money";

import {
  Package,
  AlertCircle,
  CheckCircle2,
  Zap,
  Info,
  Palette,
  Ruler,
} from "lucide-react";

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

const PACKAGING = ["Box", "Nylon", "Bottle", "Plate", "Wrap", "Carton", "Sachet", "Bag", "Other"] as const;
const MAX_IMAGES = 10;
const DRAFT_KEY = "bizhub_vendor_new_product_draft_v1";

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

function digitsOnly(s: string) {
  return String(s || "").replace(/[^\d]/g, "");
}

function formatNumberText(s: string) {
  const d = digitsOnly(s);
  if (!d) return "";
  return Number(d).toLocaleString("en-NG");
}

function parseNumberText(s: string) {
  const d = digitsOnly(s);
  return d ? Number(d) : 0;
}

function fmtNaira(n: number) {
  return formatMoneyNGN(Number(n || 0));
}

function uniq<T>(arr: T[]) {
  const out: T[] = [];
  const seen = new Set<string>();
  for (const x of arr) {
    const k = String(x);
    if (seen.has(k)) continue;
    seen.add(k);
    out.push(x);
  }
  return out;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Completion Tracker â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

function useCompletionSteps(
  name: string,
  price: number,
  images: string[],
  description: string,
  categoryKeys: MarketCategoryKey[]
) {
  return useMemo(() => {
    const steps = [
      { label: "Product name", done: !!name.trim(), required: true },
      { label: "Price", done: price > 0, required: true },
      { label: "At least 1 image", done: images.length > 0, required: true },
      { label: "Description", done: !!description.trim(), required: false },
      { label: "Category", done: categoryKeys.length > 0, required: false },
    ];

    const requiredDone = steps.filter((s) => s.required && s.done).length;
    const requiredTotal = steps.filter((s) => s.required).length;
    const allDone = steps.filter((s) => s.done).length;
    const canCreate = requiredDone === requiredTotal;
    const percent = Math.round((allDone / steps.length) * 100);

    return { steps, canCreate, percent };
  }, [name, price, images, description, categoryKeys]);
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Main Component â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

export default function VendorNewProductPage() {
  const router = useRouter();

  // Form state
  const [name, setName] = useState("");
  const [description, setDescription] = useState("");
  const [priceText, setPriceText] = useState("");
  const [stockText, setStockText] = useState("");
  const [packagingChoice, setPackagingChoice] = useState("Box");
  const [packagingOther, setPackagingOther] = useState("");
  const [images, setImages] = useState<string[]>([]);
  const [optionGroups, setOptionGroups] = useState<OptionGroup[]>([]);
  const [coverAspect, setCoverAspect] = useState<CoverAspectKey>("1:1");
  const [categoryKeys, setCategoryKeys] = useState<MarketCategoryKey[]>([]);
  const [categoriesTouched, setCategoriesTouched] = useState(false);
  const [colorsCsv, setColorsCsv] = useState("");
  const [sizesCsv, setSizesCsv] = useState("");

  // UI state
  const [msg, setMsg] = useState<string | null>(null);
  const [locked, setLocked] = useState(false);
  const [loading, setLoading] = useState(false);

  // Derived
  const price = useMemo(() => parseNumberText(priceText), [priceText]);
  const stock = useMemo(() => parseNumberText(stockText), [stockText]);
  const { steps, canCreate, percent } = useCompletionSteps(
    name,
    price,
    images,
    description,
    categoryKeys
  );

  const packagingFinal = useMemo(() => {
    if (packagingChoice === "Other") return packagingOther.trim() || "Other";
    return packagingChoice;
  }, [packagingChoice, packagingOther]);

  /* Draft restore */
  useEffect(() => {
    try {
      const raw = sessionStorage.getItem(DRAFT_KEY);
      if (!raw) return;
      const d = JSON.parse(raw);

      if (typeof d?.name === "string") setName(d.name);
      if (typeof d?.description === "string") setDescription(d.description);
      if (typeof d?.priceText === "string") setPriceText(d.priceText);
      if (typeof d?.stockText === "string") setStockText(d.stockText);
      if (typeof d?.packagingChoice === "string") setPackagingChoice(d.packagingChoice);
      if (typeof d?.packagingOther === "string") setPackagingOther(d.packagingOther);
      if (Array.isArray(d?.images)) setImages(d.images.slice(0, MAX_IMAGES));
      if (Array.isArray(d?.optionGroups)) setOptionGroups(d.optionGroups);
      const ca = normalizeCoverAspect(d?.coverAspect);
      if (ca) setCoverAspect(ca);
      if (Array.isArray(d?.categoryKeys)) setCategoryKeys(d.categoryKeys.slice(0, 3));
      if (typeof d?.categoriesTouched === "boolean") setCategoriesTouched(d.categoriesTouched);
      if (typeof d?.colorsCsv === "string") setColorsCsv(d.colorsCsv);
      if (typeof d?.sizesCsv === "string") setSizesCsv(d.sizesCsv);
    } catch {}
  }, []);

  /* Draft save */
  useEffect(() => {
    const t = setTimeout(() => {
      try {
        sessionStorage.setItem(
          DRAFT_KEY,
          JSON.stringify({
            name,
            description,
            priceText,
            stockText,
            packagingChoice,
            packagingOther,
            images: images.slice(0, MAX_IMAGES),
            optionGroups,
            coverAspect,
            categoryKeys: categoryKeys.slice(0, 3),
            categoriesTouched,
            colorsCsv,
            sizesCsv,
            ts: Date.now(),
          })
        );
      } catch {}
    }, 300);
    return () => clearTimeout(t);
  }, [
    name,
    description,
    priceText,
    stockText,
    packagingChoice,
    packagingOther,
    images,
    optionGroups,
    coverAspect,
    categoryKeys,
    categoriesTouched,
    colorsCsv,
    sizesCsv,
  ]);

  /* Auto-suggest categories */
  useEffect(() => {
    if (categoriesTouched) return;
    const text = `${name} ${description}`.trim();
    if (!text) return;
    const current = Array.isArray(categoryKeys) ? categoryKeys : [];
    const isEmpty = current.length === 0 || (current.length === 1 && current[0] === "other");
    if (!isEmpty) return;
    setCategoryKeys(suggestCategoriesFromText(text, 3));
  }, [name, description, categoriesTouched, categoryKeys]);

  function toggleCategory(k: MarketCategoryKey) {
    setCategoriesTouched(true);
    setCategoryKeys((prev) => {
      const cur = uniq(prev).slice(0, 3);
      if (cur.includes(k)) return cur.filter((x) => x !== k);
      if (cur.length >= 3) {
        toast.info("Maximum 3 categories allowed.");
        return cur;
      }
      return [...cur, k].slice(0, 3);
    });
  }

  async function create() {
    setLoading(true);
    setMsg(null);
    setLocked(false);

    try {
      const token = await auth.currentUser?.getIdToken();
      if (!token) throw new Error("Please log in again.");

      const r = await fetch("/api/vendor/products", {
        method: "POST",
        headers: { Authorization: `Bearer ${token}`, "Content-Type": "application/json" },
        body: JSON.stringify({
          name,
          description,
          price,
          stock,
          packaging: packagingFinal,
          images: images.slice(0, MAX_IMAGES),
          optionGroups,
          variants: [],
          coverAspect,
          categoryKeys: categoryKeys.slice(0, 3),
          colorsCsv,
          sizesCsv,
        }),
      });

      const data = await r.json().catch(() => ({}));

      if (!r.ok) {
        if (data?.code === "PLAN_LIMIT_PRODUCTS") {
          setLocked(true);
          throw new Error(data?.error || "Product limit reached. Upgrade to add more.");
        }
        throw new Error(data?.error || "Could not create product.");
      }

      try {
        sessionStorage.removeItem(DRAFT_KEY);
      } catch {}

      toast.success("Product created!");
      router.push(`/vendor/products/${data.productId}/edit`);
    } catch (e: any) {
      const m = e?.message || "Could not create product.";
      setMsg(m);
      toast.error(m);
    } finally {
      setLoading(false);
    }
  }

  return (
    <div className="min-h-screen bg-gray-50 pb-32">
      <GradientHeader title="New Product" subtitle="Add to your catalog" showBack={true} />

      <div className="px-4 space-y-4 pt-4">
        {/* Completion Progress */}
        <Card className="p-4">
          <div className="flex items-center justify-between mb-3">
            <p className="text-sm font-semibold text-gray-900">Completion</p>
            <span
              className={cn(
                "text-xs font-semibold px-2 py-0.5 rounded-full",
                percent === 100 ? "bg-green-100 text-green-700" : "bg-orange-100 text-orange-700"
              )}
            >
              {percent}%
            </span>
          </div>

          <div className="h-2 bg-gray-100 rounded-full overflow-hidden">
            <div
              className={cn(
                "h-full rounded-full transition-all duration-500",
                percent === 100 ? "bg-green-500" : "bg-orange-500"
              )}
              style={{ width: `${percent}%` }}
            />
          </div>

          <div className="mt-3 space-y-1.5">
            {steps.map((step) => (
              <div key={step.label} className="flex items-center gap-2">
                {step.done ? (
                  <CheckCircle2 className="w-4 h-4 text-green-500 shrink-0" />
                ) : (
                  <div
                    className={cn(
                      "w-4 h-4 rounded-full border-2 shrink-0",
                      step.required ? "border-orange-300" : "border-gray-300"
                    )}
                  />
                )}
                <span
                  className={cn(
                    "text-xs",
                    step.done ? "text-gray-500 line-through" : step.required ? "text-gray-700" : "text-gray-400"
                  )}
                >
                  {step.label}
                  {step.required && !step.done && <span className="text-orange-500"> *</span>}
                </span>
              </div>
            ))}
          </div>
        </Card>

        {/* Error / Upgrade Message */}
        {msg && (
          <Card className={cn("p-4", locked ? "bg-orange-50 border-orange-200" : "bg-red-50 border-red-200")}>
            <div className="flex items-start gap-3">
              <AlertCircle className={cn("w-5 h-5 shrink-0 mt-0.5", locked ? "text-orange-600" : "text-red-600")} />
              <div className="flex-1">
                <p className={cn("text-sm font-medium", locked ? "text-orange-800" : "text-red-800")}>
                  {locked ? "Product limit reached" : "Something went wrong"}
                </p>
                <p className={cn("text-xs mt-1", locked ? "text-orange-600" : "text-red-600")}>{msg}</p>
                {locked && (
                  <div className="mt-3 flex gap-2">
                    <Button size="sm" onClick={() => router.push("/vendor/subscription")} leftIcon={<Zap className="w-4 h-4" />}>
                      Upgrade
                    </Button>
                    <Button size="sm" variant="secondary" onClick={() => router.push("/vendor/products")}>
                      Back
                    </Button>
                  </div>
                )}
              </div>
            </div>
          </Card>
        )}

        {/* âœ… MOVED UP: Images first */}
        <SectionCard title="Product Images" subtitle={`${images.length}/${MAX_IMAGES} uploaded`}>
          <ImageUploader
            label="Product images"
            value={images}
            onChange={(next) => setImages(next)}
            max={MAX_IMAGES}
            folderBase="bizhub/uploads/products"
            disabled={loading}
            autoOpenCrop={true}
            allowFreeAspect={false}
            aspectKey={coverAspect}
            onAspectKeyChange={setCoverAspect}
          />

          {images.length === 0 ? (
            <p className="mt-2 text-xs text-red-600 flex items-center gap-1">
              <AlertCircle className="w-3.5 h-3.5" />
              Add at least 1 image to create your product.
            </p>
          ) : (
            <p className="mt-2 text-xs text-gray-500">The first image will be your cover photo.</p>
          )}
        </SectionCard>

        {/* Product Name & Description */}
        <SectionCard title="Basic Information" subtitle="Name and description">
          <div className="space-y-3">
            <div>
              <label className="block text-xs font-medium text-gray-700 mb-1.5">
                Product Name <span className="text-orange-500">*</span>
              </label>
              <Input
                placeholder="e.g. Nike Air Max 90"
                value={name}
                onChange={(e) => setName(e.target.value)}
                disabled={loading}
                maxLength={100}
              />
            </div>

            <div>
              <label className="block text-xs font-medium text-gray-700 mb-1.5">Description</label>
              <textarea
                className="w-full border border-gray-200 rounded-2xl px-4 py-3 text-sm outline-none focus:ring-2 focus:ring-orange-500/30 focus:border-orange-300 resize-none disabled:opacity-50"
                placeholder="Describe your product â€” material, features, what makes it special..."
                value={description}
                onChange={(e) => setDescription(e.target.value)}
                disabled={loading}
                rows={4}
                maxLength={2000}
              />
              <p className="text-[11px] text-gray-400 mt-1">{description.length}/2000</p>
            </div>
          </div>
        </SectionCard>

        {/* Price & Stock */}
        <SectionCard title="Pricing & Inventory" subtitle="Set your price and stock">
          <div className="space-y-3">
            <div>
              <label className="block text-xs font-medium text-gray-700 mb-1.5">
                Price <span className="text-orange-500">*</span>
              </label>
              <div className="relative">
                <span className="absolute left-4 top-1/2 -translate-y-1/2 text-sm font-semibold text-gray-400 pointer-events-none">
                  â‚¦
                </span>
                <input
                  className="w-full border border-gray-200 rounded-2xl px-4 py-3 pl-9 text-sm outline-none focus:ring-2 focus:ring-orange-500/30 focus:border-orange-300 disabled:opacity-50"
                  placeholder="0"
                  inputMode="numeric"
                  value={priceText}
                  onChange={(e) => setPriceText(formatNumberText(e.target.value))}
                  disabled={loading}
                />
              </div>
            </div>

            <div>
              <label className="block text-xs font-medium text-gray-700 mb-1.5">Stock Quantity</label>
              <Input
                placeholder="Leave empty for unlimited"
                inputMode="numeric"
                value={stockText}
                onChange={(e) => setStockText(formatNumberText(e.target.value))}
                disabled={loading}
              />
            </div>

            <div>
              <label className="block text-xs font-medium text-gray-700 mb-1.5">Packaging</label>
              <select
                className="w-full border border-gray-200 rounded-2xl px-4 py-3 text-sm bg-white outline-none focus:ring-2 focus:ring-orange-500/30 disabled:opacity-50 appearance-none"
                value={packagingChoice}
                onChange={(e) => setPackagingChoice(e.target.value)}
                disabled={loading}
              >
                {PACKAGING.map((p) => (
                  <option key={p} value={p}>
                    {p}
                  </option>
                ))}
              </select>

              {packagingChoice === "Other" && (
                <Input
                  className="mt-2"
                  placeholder="Specify packaging type"
                  value={packagingOther}
                  onChange={(e) => setPackagingOther(e.target.value)}
                  disabled={loading}
                />
              )}
            </div>

            {(price > 0 || stockText) && (
              <div className="rounded-xl bg-gray-50 border border-gray-100 p-3 flex items-center gap-4">
                <div className="flex-1">
                  <p className="text-xs text-gray-500">Price</p>
                  <p className="text-sm font-semibold text-gray-900">{fmtNaira(price)}</p>
                </div>
                <div className="w-px h-8 bg-gray-200" />
                <div className="flex-1">
                  <p className="text-xs text-gray-500">Stock</p>
                  <p className="text-sm font-semibold text-gray-900">{stockText || "Unlimited"}</p>
                </div>
                <div className="w-px h-8 bg-gray-200" />
                <div className="flex-1">
                  <p className="text-xs text-gray-500">Packaging</p>
                  <p className="text-sm font-semibold text-gray-900">{packagingFinal}</p>
                </div>
              </div>
            )}
          </div>
        </SectionCard>

        {/* Categories */}
        <SectionCard title="Categories" subtitle="Help buyers discover your product (max 3)">
          <div className="flex flex-wrap gap-2">
            {MARKET_CATEGORIES.map((c) => (
              <Chip key={c.key} active={categoryKeys.includes(c.key)} onClick={() => toggleCategory(c.key)}>
                {c.label}
              </Chip>
            ))}
          </div>

          <div className="mt-4 space-y-3">
            <div>
              <label className="block text-xs font-medium text-gray-700 mb-1.5">
                <span className="flex items-center gap-1.5">
                  <Palette className="w-3.5 h-3.5 text-gray-400" />
                  Colors
                </span>
              </label>
              <Input
                placeholder="e.g. black, red, white"
                value={colorsCsv}
                onChange={(e) => setColorsCsv(e.target.value)}
                disabled={loading}
              />
            </div>
            <div>
              <label className="block text-xs font-medium text-gray-700 mb-1.5">
                <span className="flex items-center gap-1.5">
                  <Ruler className="w-3.5 h-3.5 text-gray-400" />
                  Sizes
                </span>
              </label>
              <Input
                placeholder="e.g. S, M, L, XL or 40, 41, 42"
                value={sizesCsv}
                onChange={(e) => setSizesCsv(e.target.value)}
                disabled={loading}
              />
            </div>
          </div>

          <div className="mt-3 flex items-start gap-2 rounded-xl bg-blue-50 border border-blue-100 p-3">
            <Info className="w-4 h-4 text-blue-500 shrink-0 mt-0.5" />
            <p className="text-xs text-blue-700">
              Colors and sizes help buyers filter search results. They don't affect stock or pricing.
            </p>
          </div>
        </SectionCard>

        {/* Variations */}
        <SectionCard title="Variations" subtitle="Optional: size, color, flavor options">
          <VariationBuilder value={optionGroups} onChange={setOptionGroups} maxGroups={10} />
        </SectionCard>

        {/* Create Button */}
        <div className="pt-2 space-y-3">
          <Button
            onClick={create}
            loading={loading}
            disabled={!canCreate || loading}
            className="w-full"
            leftIcon={<Package className="w-5 h-5" />}
          >
            Create Product
          </Button>

          {!canCreate && name.trim() && (
            <div className="rounded-xl bg-orange-50 border border-orange-100 p-3">
              <p className="text-xs text-orange-700">
                {price <= 0 && "Set a price greater than â‚¦0. "}
                {images.length === 0 && "Upload at least 1 product image."}
              </p>
            </div>
          )}

          {!name.trim() && (
            <p className="text-xs text-gray-400 text-center">
              Enter a product name, price, and image to get started.
            </p>
          )}
        </div>
      </div>
    </div>
  );
}
===== END FILE: src/app/vendor/products/new/page.tsx =====

===== MISSING: src/app/vendor/products/[productId]/edit/page.tsx =====

===== FILE: src/components/ui/Select.tsx =====
import type { SelectHTMLAttributes } from "react";
import { cn } from "@/lib/cn";

export function Select({ className, ...props }: SelectHTMLAttributes<HTMLSelectElement>) {
  return (
    <select
      className={cn(
        "w-full rounded-2xl border border-biz-line bg-white px-4 py-3 text-sm outline-none",
        "focus:ring-2 focus:ring-biz-accent/30 focus:border-biz-accent/40",
        className
      )}
      {...props}
    />
  );
}
===== END FILE: src/components/ui/Select.tsx =====


